package fr.inria.diverse.trace.plaink3.tracematerialextractor

import ecorext.Ecorext
import ecorext.EcorextFactory
import ecorext.Rule
import fr.inria.diverse.trace.gemoc.generator.CallHierarchyHelper
import java.util.ArrayList
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Map
import java.util.Set
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EOperation
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.jdt.core.IAnnotation
import org.eclipse.jdt.core.IMethod
import org.eclipse.jdt.core.IType

class K3StepExtractor {

	// Input
	private val Set<IType> allClasses
	private val EPackage extendedMetamodel

	// Input / Output
	private val Ecorext ecoreExtension

	// Transient
	private val Map<IType, EClass> stepAspectsClassToAspectedClasses = new HashMap
	private val Set<IMethod> allFunctions = new HashSet
	private val Set<IMethod> stepFunctions = new HashSet
	private val Map<IMethod, Rule> functionToRule = new HashMap
	private val Set<IType> inspectedClasses = new HashSet

	new(Set<IType> aspects, String languageName, EPackage extendedMetamodel, Ecorext inConstructionEcorext) {
		this.allClasses = aspects
		this.extendedMetamodel = extendedMetamodel
		this.ecoreExtension = inConstructionEcorext

	}

	public def void generate() {
		generateStepFromXtend(allClasses)
	}

	private def Rule getRuleOfFunction(IMethod function) {
		if (functionToRule.containsKey(function))
			return functionToRule.get(function)
		else {
			val Rule rule = EcorextFactory.eINSTANCE.createRule;
			this.ecoreExtension.rules.add(rule)

			// We find the ecore class matching the aspected java class 
			val containingClass = function.declaringType
			rule.containingClass = stepAspectsClassToAspectedClasses.get(containingClass)

			var EOperation candidate = null
			if (rule.containingClass != null) {
				candidate = rule.containingClass.EAllOperations.findFirst [ o |
					o.name.equals(function.elementName)
				]
				
			}
			if (candidate != null) {
				rule.operation = candidate
			} else {
				rule.operation = xtendFunctionToEOperation(function)
			}
				
			rule.stepRule = stepFunctions.contains(function)
			functionToRule.put(function, rule)
			return rule
		}
	}

	private def void inspectForBigStep(IMethod function) {

		// We consider that each Kermeta function is a transformation rule (even through we cannot know if it modifies anything)		
		val Rule rule = getRuleOfFunction(function)

		// We retrieve which functions are called by the function
		val callingFunctions = CallHierarchyHelper.getCallersOf(function)
		for(callingFunction : callingFunctions){
			if(allClasses.contains(callingFunction.declaringType)){ //check we look always Aspects
				
				//callingFunction is the 'body' generated by Kermeta 3,
				//we need the real function
				var callingName = callingFunction.elementName
				if(callingName.startsWith("_privk3_")){
					callingName = callingName.substring(8);
				}
				val dumbFinalName = callingName
				val realCaller = allFunctions.findFirst[elementName == dumbFinalName]
				
				val Rule callingRule = getRuleOfFunction(realCaller)
				callingRule.calledRules.add(rule)
			}
		}

		// Finally we look if this function was overriden/implemented by subtypes
		// TODO use annotation?
		val xclass = function.declaringType
		val subtypes = getSubClasses(xclass)
		for (t : subtypes) {
			for (f : t.methods) {
				if (f.elementName.equals(function.elementName)) {
					val Rule overridingRule = getRuleOfFunction(f)
					rule.overridenBy.add(overridingRule)
				}
			}
		}
	}

	private def EOperation xtendFunctionToEOperation(IMethod function) {
		val result = EcoreFactory.eINSTANCE.createEOperation
		result.name = function.elementName
		// TODO finish the translation and/or ask Thomas
		// TODO or consider it is already in the ecore?
		return result
	}

	private def void inspectClass(IType type) {

		if (!inspectedClasses.contains(type)) {
			
			//Collect all functions not generated by Kermeta 3 (ie prefixed "_privk3_")
			allFunctions.addAll(type.methods.filter[!elementName.startsWith("_privk3_")])

			// For each aspect annotation of the class 
			for(a : getAspectAnnotations(type)){

				// We find the JVM aspected class
				val aspectedEClass = getAspectized(a)

				// We store the aspect class and the aspected class
				stepAspectsClassToAspectedClasses.put(type, aspectedEClass)

				// And we store all the functions with @Step
				stepFunctions.addAll(type.methods.filter[isStep])
			}
			inspectedClasses.add(type)
		}
	}

	private def generateStepFromXtend(Set<IType> files) {

		// First we look for functions, step aspects and step functions
		// Will fill the variables stepAspectsClassToAspectedClasses, allFunctions and stepFunctions		
		for (c : allClasses) {
			inspectClass(c)
		}

		// Next we create the Rule objects with all that
		for (function : allFunctions) {
			inspectForBigStep(function)
		}

	}

	/**
	 * Find annotations "@Aspect"
	 */
	private def List<IAnnotation> getAspectAnnotations(IType type){
		//TODO compare with: fr.inria.diverse.k3.al.annotationprocessor.Aspect
		if(type.isClass){
			return
				type.annotations.filter[annot |
					val name = annot.elementName //may be qualified
					val lastDotIndex = name.lastIndexOf('.')
					var simpleName = name
					if(lastDotIndex !== -1){
						simpleName = name.substring(lastDotIndex + 1)
					}
					simpleName.equals("Aspect")
				].toList
		}
		
		return new ArrayList<IAnnotation>()
	}
	
	/**
	 * Return true if 'method' is tagged with "@Step"
	 */
	private def boolean isStep(IMethod method){
		//TODO: compare with: fr.inria.diverse.k3.al.annotationprocessor.Step
		method.annotations.exists[annot |
			val name = annot.elementName //may be qualified
			val lastDotIndex = name.lastIndexOf('.')
			var simpleName = name
			if(lastDotIndex !== -1){
				simpleName = name.substring(lastDotIndex + 1)
			}
			return simpleName.equals("Step")
		]
	}
	
	/**
	 * Return direct sub types
	 */
	private def List<IType> getSubClasses(IType type){
		val hierarchy = type.newTypeHierarchy(new NullProgressMonitor)
		return hierarchy.getSubclasses(type)
	}
	
	private def EClass getAspectized(IAnnotation annot){
		val aspectedClassName = annot.memberValuePairs.findFirst[p|p.memberName == "className"].value as String
		return extendedMetamodel
				.eAllContents
				.filter(EClass)
				.findFirst[c1 |	aspectedClassName.equals(c1.name)]
	}
}
