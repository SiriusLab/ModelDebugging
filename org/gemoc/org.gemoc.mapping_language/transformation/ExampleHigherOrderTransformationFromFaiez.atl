module AddTraces;

create 
		DSML2FiacreWithTraces : ATL,  
		DSML2FiacreMetaModel : Ecore,
		Fiacre2DSML: ATL
from 
		DSML: Ecore, 
		DSMLSemantics: Ecore,  
		DSML2Fiacre : ATL, 
		Fiacre: Ecore, 
		FiacreSemantics: Ecore;

helper def : inElements : Set(ATL!"ATL::LocatedElement") = 
	ATL!"ATL::LocatedElement".allInstancesFrom('DSML2Fiacre')->asSet();

rule Unit {
    from s : ATL!"ATL::Unit" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"ATL::Unit")
		else false endif)
    to t : ATL!"ATL::Unit" in DSML2FiacreWithTraces  (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries)
}

rule Library {
    from s : ATL!"ATL::Library" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Library" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        helpers <- s.helpers)
}

rule Query {
    from s : ATL!"ATL::Query" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Query" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        libraries <- s.libraries,
        body <- s.body,
        helpers <- s.helpers)
}

rule Module {
    from s : ATL!"ATL::Module" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Module" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isRefining <- s.isRefining,
        libraries <- s.libraries,
        inModels <- s.inModels,
        outModels <- s.outModels.append(t2),
        elements <- s.elements),
		
		-- Ajouter sur le create du module un SpemModel2FiacreModel : SpemMetaModel2FiacreMetaModel
		--create FiacreModel : FiacreMetaModel, SpemModel2FiacreModel : SpemMetaModel2FiacreMetaModel
		t2: ATL!"OCL::OclModel" in DSML2FiacreWithTraces (
			name <- s.inModels->first().name+'2'+s.outModels->first().name,
			metamodel <- dsml2fiacre_metamodel
		),
		dsml2fiacre_metamodel: ATL!"OCL::OclModel" in DSML2FiacreWithTraces (
			name <- s.inModels->first().metamodel.name+'2'+s.outModels->first().metamodel.name
		),
		
		--Génération de la transformation de retour
		atl_module : ATL!"ATL::Module" in Fiacre2DSML (
		 	name <- 'TM3'+s.outModels->first().name+'2TM3'+s.inModels->first().name,
			inModels <- Sequence{fiacre_model, fiacre_semantics, dsml_model, dsml2fiacre},
			outModels <- Sequence{semantics_dsml_model},
			elements <- Sequence{main_scenario_rule, 
								thisModule.matched_rule_has_events->collect(mr|mr.outPattern.elements)->flatten()->select(x|x.isA_DSMLEvent())->collect(dsml_event | thisModule.resolveTemp(dsml_event,'back_matched_rule')),
								thisModule.matched_rule_has_events->collect(mr|thisModule.MatchedRule2BackHelper(mr))}->flatten()
			
		),
		fiacre_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'FiacreModel',
			metamodel <- fiacre_meta_model
		),
		fiacre_meta_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'FiacreMetaModel'
		),
		fiacre_semantics: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SemanticsFiacreModel',
			metamodel <- semantics_fiacre_meta_model
		),
		semantics_fiacre_meta_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'FiacreSemanticsMetaModel'
		),
		dsml_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SpemModel',
			metamodel <- dsml_meta_model
		),
		dsml_meta_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SpemMetaModel'
		),
		dsml2fiacre: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SpemModel2FiacreModel',
			metamodel <- dsml2fiacre_meta_model
		),
		dsml2fiacre_meta_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SpemMetaModel2FiacreMetaModel'
		),
		semantics_dsml_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SemanticsSpemModel',
			metamodel <- semantics_dsml_meta_model
		),
		semantics_dsml_meta_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SemanticsSpemMetaModel'
		),
		main_scenario_rule: ATL!"ATL::MatchedRule" in Fiacre2DSML (
			name <- 'FiacreScenario2SpemScenario',
			outPattern <- out_pattern_scn,
			inPattern <- in_pattern_scn
		),
		out_pattern_scn: ATL!"ATL::OutPattern" in Fiacre2DSML (
			elements <- Sequence{sim_event_simple_out}
		),
		sim_event_simple_out: ATL!"ATL::SimpleOutPatternElement" in Fiacre2DSML (
			varName <- 'spem_semantics_scn',
			type <- type_binding_sim_event,
			bindings <- Sequence{binding_sim_event}
		),
		type_binding_sim_event: ATL!"OCL::OclModelElement" in Fiacre2DSML (
			name <- 'spemSemantics::spemTM3::Scenario',
			model <- dsml_semantics_model
		),
		dsml_semantics_model: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'SpemSemanticsMetaModel'							 
		),
		binding_sim_event: ATL!"ATL::Binding" in Fiacre2DSML (
			propertyName <- 'simEvents',
			value <- value_scn
		),
		value_scn: ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML (
			name <- 'simEvents',
			source <- source_scn
		),
		source_scn: ATL!"OCL::VariableExp" in Fiacre2DSML (
		),
		in_pattern_scn: ATL!"ATL::InPattern" in Fiacre2DSML (
			elements <- Sequence{in_pattern_scn_element}													 
		),
		in_pattern_scn_element: ATL!"ATL::SimpleInPatternElement" in Fiacre2DSML (
			varName <- 'fcr_scn',
			variableExp <- source_scn,
			type <- type_in_pattern_source
		),
		type_in_pattern_source: ATL!"OCL::OclModelElement" in Fiacre2DSML (
			name <- 'fiacreSemantics::fiacreTM3::Scenario',
			model <- model_in_pattern
		),
		model_in_pattern: ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'FiacreSemanticsMetaModel'
		)		
}

rule Helper {
    from s : ATL!"ATL::Helper" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Helper" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        definition <- s.definition)
}

rule MainMatchedRule {
    from s : ATL!"ATL::MatchedRule" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"ATL::MatchedRule")
		else false endif
		
		and
		-- vérifier s'il s'agit de la règle principale pour collecter les traces
		s.isTheMainMatchedRule() )
		
		
		
    to t : ATL!"ATL::MatchedRule" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule),
		
		--  Ajouter la collecte des traces dans la rule principale par exemple Program2Process
		-- SpemMetaModel2FiacreMetaModel : SpemMetaModel2FiacreMetaModel!Spem2Fiacre
	   t2 : ATL!"ATL::SimpleOutPatternElement" in DSML2FiacreWithTraces (
        varName <- s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name,
		type <- trace_type
		,
		--le nbre de bidings est le nombre de de regles qui contienent des évènements
		-- dans ce cas on a un seul binding
		bindings <- Sequence{thisModule.matched_rule_has_events->collect(mr|thisModule.MatchedRule2Binding(mr))}
        ),
		trace_type: ATL!"OCL::OclModelElement" in DSML2FiacreWithTraces (
			name <-  s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name,
			model <- trace_model
		),
		trace_model: ATL!"OCL::OclModel" in DSML2FiacreWithTraces(
				name<- s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name
		)
		,
-- 		génération du métamodèle de trace
--
		ecore_metamodel: Ecore!EPackage in DSML2FiacreMetaModel(
		name <- s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name,
		nsURI <- 'http://org.topcased.'+s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name,
		nsPrefix <- s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name,
		eClassifiers <- Sequence{main_eclassifier, thisModule.matched_rule_has_events->collect(mr|thisModule.MatchedRule2Eclassifier(mr))}->flatten()
		),
		main_eclassifier: Ecore!EClass in DSML2FiacreMetaModel
		(
			name <- s.refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().outModels->first().metamodel.name,
			eStructuralFeatures <- Sequence{thisModule.matched_rule_has_events->collect(mr|thisModule.MatchedRule2StructuralFeature(mr))}
		)
		
		do{
			-- on ajoute l'élement t2 qui correspond à la trace dans la règle principale
			t.outPattern.elements <- t.outPattern.elements->including(t2);
			'zz'.debug('ee');
			thisModule.matched_rule_has_events.debug('matched rule');
		}
}

unique lazy rule MatchedRule2Eclassifier{
	from s : ATL!"ATL::MatchedRule" in DSML2FiacreWithTraces
	to
	-- workdefinitionTraces <-
	b : Ecore!EClass in DSML2FiacreMetaModel(
		name <- s.inPattern.elements->first().type.name+'2Fiacre',
		eStructuralFeatures <- Sequence{dsml_ref, tag_ref, instance_ref}
	),
	dsml_ref: Ecore!EReference in DSML2FiacreMetaModel  (
		name <- s.inPattern.elements->first().varName,
		eType <- Ecore!EClassifier.allInstancesFrom('DSML')
					->select(class|class.name=s.inPattern.elements->first().type.name)->first()
	),
	tag_ref: Ecore!EReference in DSML2FiacreMetaModel(
		name <- 'tag',
		eType <- Ecore!EClassifier.allInstancesFrom('Fiacre')
					->select(class|class.name='TagDeclaration')->first()
	),
	instance_ref: Ecore!EReference in DSML2FiacreMetaModel(
		name <- 'instance',
		eType <- Ecore!EClassifier.allInstancesFrom('Fiacre')
					->select(class|class.name='InstanceDeclaration')->first()
	)
	
}

lazy rule MatchedRule2Binding{
	from s : ATL!"ATL::MatchedRule"
	using {liste: Sequence(ATL!"OCL::CollectionOperationCallExp")= s.outPattern.elements
					->select(e|e.isA_DSMLEvent())
					->collect(dsml_event | thisModule.resolveTemp(dsml_event,'union_value'))
					->flatten();}
	to
	-- workdefinitionTraces <-
	b : ATL!"ATL::Binding" in DSML2FiacreWithTraces(
		propertyName <- s.inPattern.elements->first().varName+'Traces'
		
	),
	--Sequence {}
	seqExp: ATL!"OCL::SequenceExp" in DSML2FiacreWithTraces()
	do{
		--imbriquer les union l'un dans l'autre et en mettant seqExp la source du premier union
		for (element in liste){
			if (liste->first()=element)
				element.source <- seqExp;
			else
				element.source <- liste->at(liste->indexOf(element)-1);	
			}
		
		b.value <- liste->last();
	}
}

lazy rule MatchedRule2BackHelper{
	from 
		s : ATL!"ATL::MatchedRule"
	to
	-- workdefinitionTraces <-
	atl_helper : ATL!"ATL::Helper" in Fiacre2DSML(
		definition <- helper_definition
	),
	helper_definition : ATL!"OCL::OclFeatureDefinition" in Fiacre2DSML(
		feature <- helper_feature,
		context_ <- helper_context
	),
	helper_feature : ATL!"OCL::Operation" in Fiacre2DSML(
		name <- 'getWorkDefinitionTraceabilityElement',
		returnType <- return_type_model_element,
		body <- helper_body
	),
	return_type_model_element : ATL!"OCL::OclModelElement" in Fiacre2DSML(
		name <- 'WorkDefinition2Fiacre',
		model <- return_type_model
	),
	return_type_model : ATL!"OCL::OclModel" in Fiacre2DSML(
		name <- 'Spem2FiacreMetaModel'
	),
	helper_body : ATL!"OCL::CollectionOperationCallExp" in Fiacre2DSML(
		operationName <- 'first',
		source <- helper_body_source
	),
	helper_body_source : ATL!"OCL::IteratorExp" in Fiacre2DSML(
		name <- 'select',
		source <- helper_body_source_source,
		body <- helper_body_source_body,
		iterators <-Sequence{iterator}
	),
	iterator : ATL!"OCL::Iterator" in Fiacre2DSML(
		varName <- 'trace'
	),
	
	helper_body_source_source : ATL!"OCL::OperationCallExp" in Fiacre2DSML(
		operationName <- 'allInstances',
		source <- helper_body_source_source_source
	),
	helper_body_source_source_source : ATL!"OCL::OclModelElement" in Fiacre2DSML(
		name <- 'WorkDefinition2Fiacre',
		model <- model_helper_body_source_source_model
	),
	model_helper_body_source_source_model : ATL!"OCL::OclModel" in Fiacre2DSML(
		name <- 'Spem2FiacreMetaModel'
	),
	helper_body_source_body : ATL!"OCL::OperatorCallExp" in Fiacre2DSML(
		operationName <- 'and',
		source <- helper_body_source_body_source,
		arguments <- Sequence{helper_body_source_body_arguments}
	),
	helper_body_source_body_source : ATL!"OCL::OperatorCallExp" in Fiacre2DSML(
		operationName <- '=',
		source <- helper_body_source_body_source_source,
		arguments <- Sequence{helper_body_source_body_source_arguments}
	),
	helper_body_source_body_source_source : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML(
		name <- 'tag',
		source <- helper_body_source_body_source_source_source
	),
	helper_body_source_body_source_source_source : ATL!"OCL::VariableExp" in Fiacre2DSML(
		referredVariable <- iterator
	),
	helper_body_source_body_source_arguments : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML(
		name <- 'tag',
		source <- helper_body_source_body_source_arguments_variable_exp
	),
	helper_body_source_body_source_arguments_variable_exp : ATL!"OCL::VariableExp" in Fiacre2DSML(
		referredVariable <- helper_body_source_body_source_arguments_variable
	),
	helper_body_source_body_source_arguments_variable : ATL!"OCL::VariableDeclaration" in Fiacre2DSML(
		varName <- 'self'
	),
	
	helper_body_source_body_arguments : ATL!"OCL::OperatorCallExp" in Fiacre2DSML(
		operationName <- '=',
		source <- helper_body_source_body_arguments_source,
		arguments <- Sequence{helper_body_source_body_arguments_arguments}
	),
	helper_body_source_body_arguments_source : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML(
		name <- 'instance',
		source <- helper_body_source_body_arguments_source_source
	),
	helper_body_source_body_arguments_source_source : ATL!"OCL::VariableExp" in Fiacre2DSML(
		referredVariable <- iterator
	),
	helper_body_source_body_arguments_arguments : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML(
		name <- 'instance',
		source <- helper_body_source_body_arguments_arguments_variable_exp
		
	),
	helper_body_source_body_arguments_arguments_variable_exp : ATL!"OCL::VariableExp" in Fiacre2DSML(
		referredVariable <- helper_body_source_body_arguments_arguments_variable
	),
	helper_body_source_body_arguments_arguments_variable : ATL!"OCL::VariableDeclaration" in Fiacre2DSML(
		varName <- 'self'
	),
	
	
	
	
	
	helper_context : ATL!"OCL::OclContextDefinition" in Fiacre2DSML(
		--name <- 'fiacreSemantics::fiacreEDMM::TagEvent',
		context_ <- model_helper_context
	),
	model_helper_context : ATL!"OCL::OclModelElement" in Fiacre2DSML(
		name <- 'fiacreSemantics::fiacreEDMM::TagEvent',
		model <- model_helper_context_model
	),
	model_helper_context_model : ATL!"OCL::OclModel" in Fiacre2DSML(
		name <- 'FiacreSemanticsMetaModel',
		model <- model_helper_context_model
	)
}


lazy rule MatchedRule2StructuralFeature{
	from s : ATL!"ATL::MatchedRule"
	to
	-- workdefinitionTraces <-
	b : Ecore!EReference in DSML2FiacreMetaModel(
		name <- s.inPattern.elements->first().varName+'Traces',
		upperBound <- -1,
		eType <- thisModule.MatchedRule2Eclassifier(s),
		containment <- true
		
	)
}


--true si une regle contient des évènements, comme par exemple WorkDefinition2Fiacre	
helper def : matched_rule_has_events: Sequence(ATL!"ATL::MatchedRule")=
	let all_matched_rule: Sequence(ATL!"ATL::MatchedRule")=
		ATL!"ATL::MatchedRule".allInstancesFrom('DSML2Fiacre')
		->union(ATL!"ATL::LazyMatchedRule".allInstancesFrom('DSML2Fiacre'))
		->flatten()
		in
		all_matched_rule->select(mr|mr.outPattern.elements->exists(e|e.isA_DSMLEvent()).debug(mr.name));
		
rule MatchedRule {
    from s : ATL!"ATL::MatchedRule" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"ATL::MatchedRule")
		else false endif
		and
		not s.isTheMainMatchedRule() )
    to t : ATL!"ATL::MatchedRule" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)
	do{

	}
}

rule MainLazyMatchedRule {
    from s : ATL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s) and s.isTheMainMatchedRule())
    to t : ATL!"ATL::LazyMatchedRule" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        isUnique <- s.isUnique,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)

}

rule LazyMatchedRule {
    from s : ATL!"ATL::LazyMatchedRule" (thisModule.inElements->includes(s) and not s.isTheMainMatchedRule())
    to t : ATL!"ATL::LazyMatchedRule"  in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isAbstract <- s.isAbstract,
        isRefining <- s.isRefining,
        isNoDefault <- s.isNoDefault,
        isUnique <- s.isUnique,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        inPattern <- s.inPattern,
        children <- s.children,
        superRule <- s.superRule)

}

rule CalledRule {
    from s : ATL!"ATL::CalledRule" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::CalledRule" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        isEntrypoint <- s.isEntrypoint,
        isEndpoint <- s.isEndpoint,
        outPattern <- s.outPattern,
        actionBlock <- s.actionBlock,
        variables <- s.variables,
        parameters <- s.parameters)
}

rule InPattern {
    from s : ATL!"ATL::InPattern" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::InPattern" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements,
        filter <- s.filter)
}

rule OutPattern {
    from s : ATL!"ATL::OutPattern" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::OutPattern" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        elements <- s.elements)
}

rule SimpleInPatternElement {
    from s : ATL!"ATL::SimpleInPatternElement" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::SimpleInPatternElement" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        "mapsTo" <- s."mapsTo",
        models <- s.models)
}

rule SimpleOutPatternElement {
    from s : ATL!"ATL::SimpleOutPatternElement" (thisModule.inElements->includes(s) and  not (s.isA_DSMLEvent()))
    to t : ATL!"ATL::SimpleOutPatternElement" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model)
}

----------------------------------------------------------------
--Ajouter les traces pour cet élément
----------------------------------------------------------------
rule SimpleOutTagPatternElement {
    from s : ATL!"ATL::SimpleOutPatternElement" 
			(thisModule.inElements->includes(s) 	
			-- appliquer cette regle sur les éléments qui correspondent à des évènements	
			and  (s.isA_DSMLEvent()) )
    to t : ATL!"ATL::SimpleOutPatternElement" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model
		),

		
-- 		Ajouter la partie trace fiacre par exemple:
--	
--		startwd_trace : SpemMetaModel2FiacreMetaModel!WorkDefinition2Fiacre (
--   			tag <- tag_start_wd,
--   			instance <- parameterized_composition
--  		),
--  		finishwd_trace : SpemMetaModel2FiacreMetaModel!WorkDefinition2Fiacre (
--  			tag <- tag_finish_wd,
--   			instance <- parameterized_composition
--  		)

	   t2 : ATL!"ATL::SimpleOutPatternElement" in DSML2FiacreWithTraces (
        varName <- s.getTagName().toLower()+'_trace',
		type <- trace_type,
		bindings <- Sequence{tag_binding, instance_binding}
        ),
		trace_type: ATL!"OCL::OclModelElement" in DSML2FiacreWithTraces (
			name <- s.refImmediateComposite().refImmediateComposite().name,
			model <- trace_model
		),
		trace_model: ATL!"OCL::OclModel" in DSML2FiacreWithTraces (
				name<- s.refImmediateComposite().refImmediateComposite().refImmediateComposite().inModels->first().metamodel.name+'2'+s.refImmediateComposite().refImmediateComposite().refImmediateComposite().outModels->first().metamodel.name
		),
		tag_binding: ATL!"ATL::Binding" in DSML2FiacreWithTraces (
		 propertyName <- 'tag',
		 value <- tag_var_exp
		),
		tag_var_exp:  ATL!"OCL::VariableExp" in DSML2FiacreWithTraces(
			referredVariable <- s		
		),
		
		instance_binding: ATL!"ATL::Binding" in DSML2FiacreWithTraces(
		 propertyName <- 'instance',
		 value <- instance_var_exp
		),
		instance_var_exp:  ATL!"OCL::VariableExp" in DSML2FiacreWithTraces (
			referredVariable <- s.getElementType('InstanceDeclaration')	
		),
		
-- 		Ajouter la partie trace DSML
--
--  	startwd_trace.refSetValue('workdefinition', workdefinition);
--  	finishwd_trace.refSetValue('workdefinition', workdefinition);

		statement_exp: ATL!"ATL::ExpressionStat" in DSML2FiacreWithTraces(
			expression <- operation_call_exp		
		),
		operation_call_exp: ATL!"OCL::OperationCallExp" in DSML2FiacreWithTraces(
			operationName <- 'refSetValue',
			source <- var_exp,
			arguments <- Sequence{arg_string, arg_var}
		),
		var_exp: ATL!"OCL::VariableExp" in DSML2FiacreWithTraces (
				referredVariable <- t2
		),
		arg_string: ATL!"OCL::StringExp" in DSML2FiacreWithTraces (
				stringSymbol <- s.refImmediateComposite().refImmediateComposite().inPattern.elements->first().varName
		),
		arg_var: ATL!"OCL::VariableExp" in DSML2FiacreWithTraces (
				referredVariable <- s.refImmediateComposite().refImmediateComposite().inPattern.elements->first()
		),

		-- la partie union pour la collecte des traces dans la règle principale
		union_value: ATL!"OCL::CollectionOperationCallExp" in DSML2FiacreWithTraces(
				operationName <- 'union',
				arguments <- Sequence{iterate_collect}
		),
		iterate_collect: ATL!"OCL::IteratorExp" in DSML2FiacreWithTraces(
				name <- 'collect',
				source <- all_instances_operation,
				body <- resolve_temp_operation,
				iterators <- Sequence{iterator_var}
		),
		all_instances_operation: ATL!"OCL::OperationCallExp" in DSML2FiacreWithTraces(
				operationName <- 'allInstances',
				source <- ocl_model_element
		),
		ocl_model_element: ATL!"OCL::OclModelElement" in DSML2FiacreWithTraces(
				name <- s.refImmediateComposite().refImmediateComposite().inPattern.elements->first().type.name,
				model <- ocl_model
		),
		ocl_model: ATL!"OCL::OclModel"in DSML2FiacreWithTraces (
				name <- s.refImmediateComposite().refImmediateComposite().inPattern.elements->first().type.model.name
		),
		resolve_temp_operation: ATL!"OCL::OperationCallExp" in DSML2FiacreWithTraces(
				operationName <- 'resolveTemp',
				source <- ocl_var_exp,
				arguments <- Sequence{arg_var_exp, arg_string_exp}
		),
		ocl_var_exp: ATL!"OCL::VariableExp" in DSML2FiacreWithTraces(
				referredVariable <- this_module_var
		),
		this_module_var: ATL!"OCL::VariableDeclaration" in DSML2FiacreWithTraces (
				varName <- 'thisModule'
		),
		arg_var_exp: ATL!"OCL::VariableExp" in DSML2FiacreWithTraces (
				referredVariable <- this_module_var
		),
		arg_string_exp: ATL!"OCL::StringExp" in DSML2FiacreWithTraces(
				stringSymbol <- s.getTagName().toLower()+'_trace'
		),
		iterator_var: ATL!"OCL::Iterator" in DSML2FiacreWithTraces (
				varName <- 'var',
				variableExp <- arg_var_exp
		),
		
		
		-- la partie transformation de retour 
		back_matched_rule: ATL!"ATL::MatchedRule" in Fiacre2DSML (
			name <- 'TagEvent2'+s.getTagName(),
			outPattern <- back_out_pattern,
			inPattern <- back_in_pattern
		),
		back_out_pattern : ATL!"ATL::OutPattern" in Fiacre2DSML (
			elements <- Sequence{back_dsml_event}
		),
		back_dsml_event : ATL!"ATL::SimpleOutPatternElement" in Fiacre2DSML (
			varName <- 'spem_event',
			type <- type_back,
			bindings <- Sequence{binding_event}
		),
		type_back : ATL!"OCL::OclModelElement" in Fiacre2DSML (
			name <- 'spemSemantics::spemEDMM::'+s.getTagName(),
			model <- model_back
		),
		model_back : ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'spemSemanticsMetaModel'
		),
		binding_event : ATL!"ATL::Binding" in Fiacre2DSML (
			propertyName <- 'workdefinition',
			value <- back_value
		),
		back_value : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML (
			name <- 'workdefinition',
			source <- source_back
		),
		source_back : ATL!"OCL::OperationCallExp" in Fiacre2DSML (
			operationName <- 'getWorkDefinitionTraceabilityElement',
			source <- source_ocl_var
		),
		source_ocl_var : ATL!"OCL::VariableExp" in Fiacre2DSML (
			referredVariable <- back_element_in
		),
		
		back_in_pattern : ATL!"ATL::InPattern" in Fiacre2DSML (
			elements <- Sequence{back_element_in},
			filter <- filter_in_back
		),
		back_element_in : ATL!"ATL::SimpleInPatternElement" in Fiacre2DSML (
			varName <- 'fcr_event',
			type <- in_model_element_back
		),
		in_model_element_back : ATL!"OCL::OclModelElement" in Fiacre2DSML (
			name <- 'fiacreSemantics::fiacreEDMM::TagEvent',
			model <- in_model_back
		),
		in_model_back : ATL!"OCL::OclModel" in Fiacre2DSML (
			name <- 'FiacreSemanticsMetaModel'
		),
		filter_in_back : ATL!"OCL::OperatorCallExp" in Fiacre2DSML (
			operationName <- '=',
			source <- source_name,
			arguments <- event_string_exp
		),
		event_string_exp : ATL!"OCL::StringExp" in Fiacre2DSML (
			stringSymbol <- s.getTagName()
		),
		source_name : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML (
			name <-   'name',
			source <- source_tag
		),
		source_tag : ATL!"OCL::NavigationOrAttributeCallExp" in Fiacre2DSML (
			name <-   'tag',
			source <- source_var
		),
		source_var : ATL!"OCL::VariableExp" in Fiacre2DSML (
			referredVariable <- back_element_in
		)
		
		
	do
	{	
--		ajouter la trace partie fiacre construite précédémment dans les éléments d'une règle
		t.refImmediateComposite().elements <- t.refImmediateComposite().elements->including(t2);
--		ajouter la trace partie DSML construite précédémment dans le block action
--		il faudra reprendre ça dans le cas où la regle ne contient pas un block. 
--		il faudra le crééer puis affecter le statement

		t.refImmediateComposite().refImmediateComposite().actionBlock.statements <- t.refImmediateComposite().refImmediateComposite().actionBlock.statements->including(statement_exp);
	}
}

-- 		retourne true si l'inPattern d'une règle correspond au premier élément 
-- 		de l'ecore du DSML
--		comme par exemple Process de Spem
-- 		on a fait pour savoir où collecter les traces construites dans les règles
helper context ATL!"ATL::MatchedRule" def: isTheMainMatchedRule() : Boolean =
	let main_rule: ATL!"ATL::MatchedRule" =
		ATL!"ATL::MatchedRule".allInstancesFrom('DSML2Fiacre')
		->union (ATL!"ATL::LazyMatchedRule".allInstancesFrom('DSML2Fiacre'))
		->flatten()
		->select(mr|mr.inPattern.elements->first().type.name=Ecore!EClassifier.allInstancesFrom('DSML')->first().name)->first()
	in
	if self = main_rule
		then 
			true
		else 
			false
	endif
	;

--		retourne l'ensemble des classes des évènements définies dans le EDMM
--		et qui ne sont pas abstraites (comme par exemple WorkDefinitionEvent)
helper def: getDSMLEvents(): Sequence(Ecore!EClassifier) = 
	Ecore!EPackage.allInstancesFrom('DSMLSemantics')->asSequence()
					->select(p|p.name.endsWith('EDMM'))->first()
					.eClassifiers->select(e|e.abstract=false);

--		retourne Vrai si un élément dont le type est TagDeclaration
--		a le nom qui figure dans l'ensemble des évènements
--		exemple TagDeclaration dont le nom= 'StartWD' => True
--		exemple de TagDeclaration dont le nom= 'lost' => False
helper context ATL!"ATL::SimpleOutPatternElement" def: isA_DSMLEvent() : Boolean =
	if self.type.name='TagDeclaration' then
		thisModule.getDSMLEvents()->collect(ec|ec.name)->flatten()->includes(self.getTagName())
	else
		false
	endif;

--		retourne le name d'un tag
-- 		par exemple on a (il faut) un binding name <- 'XXXX'
--		cet helper nous renvoie 'XXXX'
helper context ATL!"ATL::SimpleOutPatternElement" def : getTagName() :String =
	let bs : Sequence(ATL!"ATL::Binding")=
	self.bindings->select(b|b.propertyName='name')
	in
		if(bs.size()= 0)
			then 
				''
			else
				bs->first().value.stringSymbol
			endif;

--		retourne l'élément dont le nom du type = element_type 
helper context ATL!"ATL::SimpleOutPatternElement" def: getElementType(element_type: String): ATL!"ATL::SimpleOutPatternElement"=
	ATL!"ATL::SimpleOutPatternElement".allInstances()
	->select(e|e.refImmediateComposite()=self.refImmediateComposite())
	->select(e|e.type.name=element_type)->first();

	




rule ForEachOutPatternElement {
    from s : ATL!"ATL::ForEachOutPatternElement" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ForEachOutPatternElement" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp,
        sourceElement <- s.sourceElement,
        bindings <- s.bindings,
        model <- s.model,
        collection <- s.collection,
        iterator <- s.iterator)
}

rule Binding {
    from s : ATL!"ATL::Binding" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::Binding" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        value <- s.value)
}

rule RuleVariableDeclaration {
    from s : ATL!"ATL::RuleVariableDeclaration" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::RuleVariableDeclaration" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule LibraryRef {
    from s : ATL!"ATL::LibraryRef" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::LibraryRef" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name)
}

rule ActionBlock {
    from s : ATL!"ATL::ActionBlock" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ActionBlock" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        statements <- s.statements)
}

rule ExpressionStat {
    from s : ATL!"ATL::ExpressionStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ExpressionStat" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        expression <- s.expression)
}

rule BindingStat {
    from s : ATL!"ATL::BindingStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::BindingStat" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        propertyName <- s.propertyName,
        source <- s.source,
        value <- s.value)
}

rule IfStat {
    from s : ATL!"ATL::IfStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::IfStat" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        condition <- s.condition,
        thenStatements <- s.thenStatements,
        elseStatements <- s.elseStatements)
}

rule ForStat {
    from s : ATL!"ATL::ForStat" (thisModule.inElements->includes(s))
    to t : ATL!"ATL::ForStat" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        iterator <- s.iterator,
        collection <- s.collection,
        statements <- s.statements)
}

rule VariableExp {
    from s : ATL!"OCL::VariableExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::VariableExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        referredVariable <- s.referredVariable)
}

rule SuperExp {
    from s : ATL!"OCL::SuperExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SuperExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule StringExp {
    from s : ATL!"OCL::StringExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::StringExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        stringSymbol <- s.stringSymbol,
        type <- s.type)
}

rule BooleanExp {
    from s : ATL!"OCL::BooleanExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BooleanExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        booleanSymbol <- s.booleanSymbol,
        type <- s.type)
}

rule RealExp {
    from s : ATL!"OCL::RealExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::RealExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        realSymbol <- s.realSymbol,
        type <- s.type)
}

rule IntegerExp {
    from s : ATL!"OCL::IntegerExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IntegerExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        integerSymbol <- s.integerSymbol,
        type <- s.type)
}

rule BagExp {
    from s : ATL!"OCL::BagExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BagExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule OrderedSetExp {
    from s : ATL!"OCL::OrderedSetExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OrderedSetExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SequenceExp {
    from s : ATL!"OCL::SequenceExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SequenceExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule SetExp {
    from s : ATL!"OCL::SetExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SetExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule TupleExp {
    from s : ATL!"OCL::TupleExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TupleExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        tuplePart <- s.tuplePart)
}

rule TuplePart {
    from s : ATL!"OCL::TuplePart" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TuplePart" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule MapExp {
    from s : ATL!"OCL::MapExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::MapExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        elements <- s.elements)
}

rule MapElement {
    from s : ATL!"OCL::MapElement" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::MapElement" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        key <- s.key,
        value <- s.value)
}

rule EnumLiteralExp {
    from s : ATL!"OCL::EnumLiteralExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::EnumLiteralExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclUndefinedExp {
    from s : ATL!"OCL::OclUndefinedExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclUndefinedExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type)
}

rule NavigationOrAttributeCallExp {
    from s : ATL!"OCL::NavigationOrAttributeCallExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::NavigationOrAttributeCallExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source)
}

rule OperationCallExp {
    from s : ATL!"OCL::OperationCallExp" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"OCL::OperationCallExp")
		else false endif)
    to t : ATL!"OCL::OperationCallExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule OperatorCallExp {
    from s : ATL!"OCL::OperatorCallExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OperatorCallExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule CollectionOperationCallExp {
    from s : ATL!"OCL::CollectionOperationCallExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::CollectionOperationCallExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        operationName <- s.operationName,
        type <- s.type,
        source <- s.source,
        arguments <- s.arguments)
}

rule IterateExp {
    from s : ATL!"OCL::IterateExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IterateExp" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators,
        result <- s.result)
}

rule IteratorExp {
    from s : ATL!"OCL::IteratorExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IteratorExp"  in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        source <- s.source,
        body <- s.body,
        iterators <- s.iterators)
}

rule LetExp {
    from s : ATL!"OCL::LetExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::LetExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        variable <- s.variable,
        in_ <- s.in_)
}

rule IfExp {
    from s : ATL!"OCL::IfExp" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IfExp" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        type <- s.type,
        thenExpression <- s.thenExpression,
        condition <- s.condition,
        elseExpression <- s.elseExpression)
}

rule VariableDeclaration {
    from s : ATL!"OCL::VariableDeclaration" (
		if thisModule.inElements->includes(s) then
			s.oclIsTypeOf(ATL!"OCL::VariableDeclaration")
		else false endif)
    to t : ATL!"OCL::VariableDeclaration" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Iterator {
    from s : ATL!"OCL::Iterator" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Iterator" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule Parameter {
    from s : ATL!"OCL::Parameter" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Parameter" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        id <- s.id,
        varName <- s.varName,
        type <- s.type,
        initExpression <- s.initExpression,
        variableExp <- s.variableExp)
}

rule StringType {
    from s : ATL!"OCL::StringType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::StringType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BooleanType {
    from s : ATL!"OCL::BooleanType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BooleanType" (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule IntegerType {
    from s : ATL!"OCL::IntegerType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::IntegerType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule RealType {
    from s : ATL!"OCL::RealType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::RealType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule BagType {
    from s : ATL!"OCL::BagType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::BagType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OrderedSetType {
    from s : ATL!"OCL::OrderedSetType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OrderedSetType" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SequenceType {
    from s : ATL!"OCL::SequenceType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SequenceType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule SetType {
    from s : ATL!"OCL::SetType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::SetType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        elementType <- s.elementType)
}

rule OclAnyType {
    from s : ATL!"OCL::OclAnyType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclAnyType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule "TupleType" {
    from s : ATL!"OCL::TupleType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TupleType" in DSML2FiacreWithTraces(
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        attributes <- s.attributes)
}

rule TupleTypeAttribute {
    from s : ATL!"OCL::TupleTypeAttribute" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::TupleTypeAttribute" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type)
}

rule OclModelElement {
    from s : ATL!"OCL::OclModelElement" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclModelElement" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        model <- s.model)
}

rule MapType {
    from s : ATL!"OCL::MapType" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::MapType" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        type <- s.type,
        valueType <- s.valueType,
        keyType <- s.keyType)
}

rule OclFeatureDefinition {
    from s : ATL!"OCL::OclFeatureDefinition" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclFeatureDefinition" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        feature <- s.feature,
        context_ <- s.context_)
}

rule OclContextDefinition {
    from s : ATL!"OCL::OclContextDefinition" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclContextDefinition" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        context_ <- s.context_)
}

rule Attribute {
    from s : ATL!"OCL::Attribute" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Attribute" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        initExpression <- s.initExpression,
        type <- s.type)
}

rule Operation {
    from s : ATL!"OCL::Operation" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::Operation"  in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        parameters <- s.parameters,
        returnType <- s.returnType,
        body <- s.body)
}

rule OclModel {
    from s : ATL!"OCL::OclModel" (thisModule.inElements->includes(s))
    to t : ATL!"OCL::OclModel" in DSML2FiacreWithTraces (
        location <- s.location,
        commentsBefore <- s.commentsBefore,
        commentsAfter <- s.commentsAfter,
        name <- s.name,
        metamodel <- s.metamodel,
        elements <- s.elements,
        model <- s.model)
}
