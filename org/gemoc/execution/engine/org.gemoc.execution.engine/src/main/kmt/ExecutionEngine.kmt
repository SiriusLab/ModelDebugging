using kermeta::standard::*
using kermeta::io::StdIO => stdio
using utils::*

package engine{
	class ExecutionEngine inherits Loggable
	{
		attribute clock : Integer
		reference solver : Solver
		reference eventMatcher : Matcher
		reference currentEvents : OrderedCollection<ScheduledEvent>
		
		operation initialize(solver : Solver, level : LogLevel) : Void is do
			self.moc := moc
			self.finished := false
			self.clock := 0
			self.getLogger("ExecutionEngine", level)
		end
		
		// Checkout all the events in the queue of the MoC and consume them
		operation run() : Void is do
        	logger.info("Starting the execution engine...")
	        
	        // Looping from the clock starting point (0) to the date of the latest scheduled event
	        from self.finished
	        until self.finished == true
	        loop
	        	from var currentEvents : Collection<DomainSpecificEvent> init self.eventMatcher.match(self.solver.getNext())
	        	until currentEvents.empty()
	        	loop
	        		var feedback : Feedback init currentEvents.first.consume()
	        		dealWithFeedback(feedback)
	        	end
	        
	        	self.clock := self.clock + 1
	        	if self.clock > 100 then self.finished := true end
	        end
	        logger.info("Shutting down the execution engine. Number of rounds: " + self.clock.toString())
		end
		
		operation dealWithFeedback(feedback : Feedback) is do
			//
		end
        
        
        method toString() : String is do
        	result := "<ExecutionEngine@["
        			+ " ; clock=" + self.clock.toString()
        			+ "]>"
        end
	}
	
	class Solver {
		operation getNext() : Collection<ClockTick> is do
			result := Sequence<ClockTick>.new
		end
	}
	
	class Matcher{
		operation match(ticks : Collection<ClockTick>) : Collection<DomainSpecificEvent> is do
			result := Sequence<DomainSpecificEvent>.new
		end 
	}
	
	class DomainSpecificEvent{
		reference dsa : DomainSpecificAction
		reference pattern : Sequence<ClockTick>
		
		operation consume() : Feedback is do
			result := self.dsa.execute()
		end
	}
	
	class Feedback{
		operation initialize() : Feedback is do
			result := self
		end
	}
	
	class DomainSpecificAction{
		operation execute() : Feedback is do
			result := Feedback.new.initialize()
		end
	}
	
	class ClockTick{
		
	}
}