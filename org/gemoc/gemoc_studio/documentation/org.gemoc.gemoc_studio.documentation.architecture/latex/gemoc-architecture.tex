\documentclass{gemoc} %% no option needed, default is : 10pt, twoside, babel[ english] , graphicx
\usepackage{color}
\usepackage[colorlinks=true]{hyperref}

\task{4.1.1}
\title{Gemoc Architectural description}
\docnumber{D4.1.1}
\version{1.1}

\companycopyright{Consortium GEMOC}  %% Appear in the foot page

\begin{document}
\maketitle

%Start of user code revisions
\begin{revisions}
	\begin{revtable}
		\dates{03/06/2013}{10/09/2013}{}{}{}
		\writers{Didier Vojtisek}{Vincent Fontanella}{}{}{}
		\approvers{Benoit Combemale}{}{}{}{}
	\end{revtable}
	\begin{revisionlabels}
		\revlabel{Initial version}
		\revlabel{Update of the global architecture}
	\end{revisionlabels}
\end{revisions}
%End of user code

%Start of user code tableofauthors
\begin{tableofauthors}
	\leadauthor{Didier Vojtisek}{INRIA}
	\redactor{M\'elanie Bats}{OBEO}
	\redactor{Vincent Fontanella}{INRIA}
	\contributor{All}{All}
\end{tableofauthors}
%End of user code

\tableofcontents
\newpage

\chapter{Introduction}
%Start of user code Introduction

%End of user code 

\section{Purpose}
%Start of user code IntroductionPurpose
This document presents the architectural design of the GEMOC Studio.\newline We describe the various components and metamodels integrated into the studio.
\newline A website is available to have more informations and follow the \texttt{GEMOC Initiative} : \url{www.gemoc.org}
\newline A continuous integration is available at the link below : \newline\url{https://ci.inria.fr/gemoc}
%End of user code

\section{Perimeter}
%Start of user code IntroductionPerimeter

%End of user code

\section{Definitions, Acronyms and Abbreviations}
%Start of user code IntroductionDefinitions
\begin{itemize}
	\item \textbf{Architecture}  : fundamental conception of a system in its environment
 embodied in its elements, their relationships between each other and to its 
environment, and the principles guiding its design and evolution
	\item \textbf{Architectural Description} : collection of information items used to describe an architecture
	\item \textbf{Architecture Framework} : set of common practices for ArchitecturalDescription established within a specific domain or stakeholder community
	\item \textbf{Bundle} : a group of Java classes and additional resources equipped with a detailed manifest defining the entire component, its provided and required classes
	\item \textbf{Model} : model which contributes to the convent of a View
	\item \textbf{Update-Site} : an update-site is an aggregation of deployment units which might be used to provision a target platform
	\item \textbf{Stakeholder} : (of a system) individual, team, organization, or classes thereof, having concerns with respect to a system 
	\item \textbf{Language workbench} : a language workbench offers the facilities for designing and implementing modeling languages.
	\item \textbf{Language Designer} : a language designer is the user of the langage workbench.
	\item \textbf{Modeling workbench} : a modeling workbench offers all the required facilities for editing and animating domain specific models according to a given modeling language.
	\item \textbf{Domain engineer} :
	\item \textbf{GEMOC Studio} : Eclipse-based studio integrating both the language workbench and the modeling workbench.
	\item \textbf{DSML} : Domain Specific Modeling Language
	\item \textbf{xDSML} : Executable Domain Specific Modeling Language
	\item \textbf{AS} : Abstract Syntax
	\item \textbf{MOCC} : Model of Computation and Communication
	\item \textbf{DSA} : Domain Specific Action (Language)
	\item \textbf{DSE} : Domain Specific Execution
\end{itemize}
%End of user code

\section{References}
%Start of user code IntroductionReferences
The basis of the GEMOC Studio architecture is described in the project proposal document. 
%End of user code

\section{Summary}
%Start of user code IntroductionSummary
This document describes the architecture of the GEMOC Studio, outlining every logical component along with its role and how it relates to the other components. We will detail all required and provided interfaces and define the exchanged data's format, thus describing how each individual piece of the studio is going to communicate with the others.
This document also lists the requirements regarding the technical integration of these components and guides the GEMOC partners in providing their artifacts.


%End of user code
 
\chapter{Architecture}
%Start of user code Architecture
Starting from the project prososal view of the Studio (see figure \ref{fig:ProjectProposalView}), it is refined into a component based architecture as shown in figure \ref{fig:GlobalView}. 
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/ProjectProposalView.jpg}
	\caption{Project proposal view of the GEMOC Studio}
	\label{fig:ProjectProposalView}
	\end{center}
\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/generated/GlobalView.png}
	\caption{Architecture of the GEMOC Studio}
	\label{fig:GlobalView}
	\end{center}
\end{figure}
%End of user code

\section{Introduction}
%Start of user code ArchitectureIntroduction
The logical architecture will be described with a model-based formalism describing components with input and output interfaces (including the data flow).

We can identify 3 main groups of components and artefacts in the studio.

\begin{itemize}
	\item \textbf{GEMOC components:} are the components offered by the studio that constitutes the base of the studio and provide the main functionalities (see figures \ref{fig:LogicalView} and \ref{fig:TimesquareImplementation}).
	\item \textbf{Metamodels:} these elements are the languages used by the ``GEMOC components'' to exchange data between them. (see figure \ref{fig:MetamodelList}).
	\item \textbf{Domain Specific Components:} These artefacts are the result of some of the GEMOC components and are specific to the domain. They are produced by the Domain Designers. Then, they are used by the Domain Experts in the main process as input of other component or as a tool to produce other artefact. As they are specific to the domain, these artifacts are prefixed with ``Domain Specific''. In a real domain application, this prefix would be replaced but the actual name of the domain. (see figure \ref{fig:DomainSpecificComponentList}).
\end{itemize}

\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, angle=90, totalheight=0.9\textheight]{../images/generated/LogicalView.png}
	\caption{Logical View of the GEMOC Studio}
	\label{fig:LogicalView}
	\end{center}
\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, angle=90, totalheight=0.9\textheight]{../images/generated/TimesquareImplementation.png}
	\caption{Implemetation view of the Execution Engine of the GEMOC Studio}
	\label{fig:TimesquareImplementation}
	\end{center}
\end{figure}
%\begin{figure}[htp]
%	\begin{center}
%	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/All Components list.jpg}
%	\caption{List of all the components of the GEMOC Studio}
%	\label{fig:AllComponentList}
%	\end{center}
%\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/Gemoc Metamodels Class Diagram.jpg}
	\caption{List of the metamodels of the GEMOC Studio}
	\label{fig:MetamodelList}
	\end{center}
\end{figure}
%End of user code


\section{Components}
%Start of user code ArchitectureComponents

%End of user code
\subsection{EMF Tree Editor Generator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:EMF_Tree_Editor_Generator}
%Start of user code EMF Tree Editor Generator

%End of user code
%Start of user code EMF Tree Editor GeneratorDescription
An \texttt{EMF Tree Editor} is in charge of generating a Domain Specific Editor. More specifically it generates a tree editor component for the xDSML. 

Eclipse Modeling Framework provides such component. It uses the Domain Specific metamodel provided as an ecore model and a genmodel configuration.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_EMF_Tree_Editor_Generator.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for EMF Tree Editor Generator
An ecore model representing the domain concepts of the user DSML.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Tree Editor} :
%Start of user code Domain Specific Tree Editor_output_Description for EMF Tree Editor Generator
This component produces a new component that we will reference as \emph{Domain Specific Tree Editor}.
%End of user code 
(see section~\ref{sec:Domain_Specific_Tree_Editor}.)
\end{itemize}


\subsection{Eclipse}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Eclipse}
%Start of user code Eclipse
Eclipse is an integrated development environment composed of a runtime system and an plug-in mechanism used to extend and customize the environment. It is released under the terms of the Eclipse Public License, and is a free and open source software. The GEMOC studio will be based on and fully integrated to Eclipse. Consequently most of the end user GEMOC components will be released as Eclipse plugins.
%End of user code
%Start of user code EclipseDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Eclipse.png}
\end{center}




\subsection{Eclipse Debug}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Eclipse_Debug}
%Start of user code Eclipse Debug

%End of user code
%Start of user code Eclipse DebugDescription
The Debug component of the Eclipse platform defines language independent facilities and mechanisms for:
\begin{itemize}
\item Launching programs
\item Source lookup
\item Defining and registering breakpoints
\item Event notification from programs being debugged
\item A language independent debug model
\item A language independent debug UI
\end{itemize}

The Eclipse debugger allows to control the execution process of a program interactively while watching the source code and the variables during the execution. It is possible to stop the execution on a specific element by defining breakpoints. When the program is paused, it is possible to see the variables current states and change their values.
%\begin{figure}[h]
%	\begin{center}
%	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/EclipseDebugPerspective.png}
%	\caption{Eclipse Debug screenshot}
%	\end{center}
%\end{figure}
\newline\newline Eclipse provides a special Debug perspective with default views and actions available:
\begin{itemize}
\item Set/Unset \textbf{breakpoints}
\item \textbf{Start} and \textbf{Stop} the debugger
\item Control the program execution : \textbf{Step into}, \textbf{Step over}, \textbf{Step out} and \textbf{Resume}
\item See the \textbf{Call Stack}
\item \textbf{Variables} view : display variables from the current executing stack and change the values assigned to a variable
\item \textbf{Expressions} view : get the current value of an expression from the current executing stack
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Eclipse_Debug.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_input_Description for Eclipse Debug
Java API to provide a new debugging framework. It defines interfaces for a language independent debug model, which abstract common debugging features of many languages. 
%End of user code 
(see section~\ref{sec:Debug_User_Interface}.)
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_input_Description for Eclipse Debug
JAVA API to add launch configuration types to the platform. A launch configuration is a description of how to launch a program. Launching in Eclipse is closely tied to the infrastructure for debugging.
%End of user code 
(see section~\ref{sec:Launch_Utilities}.)
\end{itemize}



\subsection{Eclipse Modeling}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Eclipse_Modeling}
%Start of user code Eclipse Modeling

%End of user code
%Start of user code Eclipse ModelingDescription
The Eclipse Modeling Project focuses on the evolution and promotion of model-based development technologies within the Eclipse community by providing a unified set of modeling frameworks, tooling, and standards implementations. The GEMOC Studio is based on many different Eclipse modeling projects :
\begin{itemize}
\item EMF : a modeling framework and code generation facility for building tools and other applications based on a structured data model.
\item GEF : provides technology to create rich graphical editors and views for the Eclipse Workbench UI.
\item GMF : an application framework for creating graphical editors using EMF and GEF.
\item Sirius : a framework which provides specific multi-view workbenches through graphical, table or tree modeling editors.
\item Xtext : a framework/tool for developing external textual DSLs based on EMF.
\item Unified Modeling Language 2.x : an EMF-based implementation of the UML 2.x metamodel for the Eclipse platform.
\item Acceleo : a template based code generation framework with high quality tooling : complete Editor, Debugger and Profiler.
\item ...
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Eclipse_Modeling.png}
\end{center}




\subsection{Execution Engine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Execution_Engine}
%Start of user code Execution Engine

%End of user code
%Start of user code Execution EngineDescription
An \texttt{Execution Engine} acts on the execution state of models under the direction of the Solver and Policy, and according to the corresponding domain specific action.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Execution_Engine.png}
\end{center}



\subsubsection{Composition Operator Applicator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Composition_Operator_Applicator}
%Start of user code Composition Operator Applicator
%End of user code
%Start of user code Composition Operator ApplicatorDescription
A \texttt{Composition Operator Applicator} is a compiler of Composition Operator for specifics models (in compliance with the corresponding xDSMls).
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Composition_Operator_Applicator.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{OperatorDefinition Model} :
%Start of user code OperatorDefinition Model_input_Description for Composition Operator Applicator
%End of user code 
(see section~\ref{sec:OperatorDefinition_Model}.)
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Composition Operator Applicator
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}


\paragraph{CEP Engine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:CEP_Engine}
%Start of user code CEP Engine
%End of user code
%Start of user code CEP EngineDescription
A \texttt{CEP Engine} provides a synchronization of two sets of steps events of various models from one coordination model.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_CEP_Engine.png}
\end{center}





\subsubsection{DSE Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSE_Compiler}
%Start of user code DSE Compiler
%End of user code
%Start of user code DSE CompilerDescription
A \texttt{DSE Compiler} provides a Concurrency Execution Model from a \texttt{Domain Specific Model}, and a \texttt{DSE Model}.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSE_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSE Model} :
%Start of user code DSE Model_input_Description for DSE Compiler
%End of user code 
(see section~\ref{sec:DSE_Model}.)
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for DSE Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Concurrency Execution Model} :
%Start of user code Concurrency Execution Model_output_Description for DSE Compiler
%End of user code 
(see section~\ref{sec:Concurrency_Execution_Model}.)
\end{itemize}

\paragraph{Timesquare MOCC To Execution Model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Timesquare_MOCC_To_Execution_Model}
%Start of user code Timesquare MOCC To Execution Model

%End of user code
%Start of user code Timesquare MOCC To Execution ModelDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Timesquare_MOCC_To_Execution_Model.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{ECL Model} :
%Start of user code ECL Model_input_Description for Timesquare MOCC To Execution Model
%End of user code 
(see section~\ref{sec:ECL_Model}.)
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Timesquare MOCC To Execution Model
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_output_Description for Timesquare MOCC To Execution Model
%End of user code 
(see section~\ref{sec:CCSL_Model}.)
\end{itemize}



\subsubsection{DSE Engine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSE_Engine}
%Start of user code DSE Engine
%End of user code
%Start of user code DSE EngineDescription
A \texttt{DSE Engine} acts on an \texttt{Execution Model}.
It provides an execution trace.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSE_Engine.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Model}.)
  \item \textbf{Execution Model} :
%Start of user code Execution Model_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Execution_Model}.)
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Execution Model} :
%Start of user code Execution Model_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Execution_Model}.)
  \item \textbf{Trigger Event Request} :
%Start of user code Trigger Event Request_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Trigger_Event_Request}.)
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Runtime_Controller}.)
  \item \textbf{Trace Model} :
%Start of user code Trace Model_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Trace_Model}.)
\end{itemize}


\subsubsection{MOCC Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:MOCC_Compiler}
%Start of user code MOCC Compiler
%End of user code
%Start of user code MOCC CompilerDescription
A \texttt{MOCC compiler} takes the specification of a \texttt{MOCC Model} to provide an implementation of this model.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_MOCC_Compiler.png}
\end{center}




\subsubsection{NEMO}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:NEMO}
%Start of user code NEMO

%End of user code
%Start of user code NEMODescription
\texttt{NEMO} is a specific MOCC based on a state machin. It interprets one concurrency model to schedule events.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_NEMO.png}
\end{center}




\subsubsection{Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Policy}
%Start of user code Policy
A \texttt{Policy} is part of the description of the control in a language. It works in conjunction with a model of computation.
The Policy component is an abstract componant whose implementations are responsible for selecting one Domain Specific Event from a vector of triggerable Domain Specific Event. Several selection strategies are provided in GEMOC.
%End of user code
%Start of user code PolicyDescription
The purpose of a Policy is to select a DSE among the possible DSE occurrences allowed by the model of computation. It can be considered as a refinement of the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Policy.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_input_Description for Policy
%\textbf{\textcolor{red}{FBO: pas sur de bien comprendre ce qu'est le DSEVM ou bien ce qu'il fait l\`a. J'aurais plut\^ot dit que Policy avait besoin du Domain Specific Event Model}}
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_output_Description for Policy
The Policy component provides one Domain Specific Event selected out of the triggerable set.
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Model}.)
\end{itemize}

\paragraph{Interactive Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Interactive_Policy}
%Start of user code Interactive Policy
The Interactive Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
It inherits from Policy component and have all its input/outputs.
%End of user code
%Start of user code Interactive PolicyDescription
The purpose of the Interactive Policy is to let the user explore the possible behaviors of a model by choosing the DSE he wants when several DSE are allowed to occur according to the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Interactive_Policy.png}
\end{center}




\paragraph{Random Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Random_Policy}
%Start of user code Random Policy
The Random Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
%End of user code
%Start of user code Random PolicyDescription
The purpose of the Random Policy is to randomly explore the possible behaviors of a model by making a random choice among all possible DSE occurrences. For instance, when executing a non deterministic automata, the random policy will randomly choose one transition among all the fireable transitions determined by the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Random_Policy.png}
\end{center}




\paragraph{Replay Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Replay_Policy}
%Start of user code Replay Policy
The Replay Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
It inherits from Policy component and have all its input/outputs.
%End of user code
%Start of user code Replay PolicyDescription
The purpose of the Replay Policy is to replay a simulation by choosing the DSE indicated in a trace model when several DSE when several DSE are allowed to occur according to the model of computation. It should also raise an error when the DSE which is indicated at a given point in the trace model is not among the DSE allowed by the model of computation (the trace model is not compatible with the behavior of the model).
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Replay_Policy.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_input_Description for Replay Policy
the model of the trace to replay.
%End of user code 
(see section~\ref{sec:Trace_Model}.)
\end{itemize}



\paragraph{Scenario Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Scenario_Policy}
%Start of user code Scenario Policy
The \texttt{Scenario Policy} is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
It inherits from Policy component and have all its input/outputs.
%End of user code
%Start of user code Scenario PolicyDescription
The purpose of the Scenario Policy is to drive a simulation by choosing the DSE indicated in a scenario when several DSE when several DSE are allowed to occur according to the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Scenario_Policy.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Scenario Model} :
%Start of user code Scenario Model_input_Description for Scenario Policy
%End of user code 
(see section~\ref{sec:Scenario_Model}.)
\end{itemize}




\subsubsection{Solver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Solver}
%Start of user code Solver

%End of user code
%Start of user code SolverDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Solver.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_input_Description for Solver
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Model}.)
  \item \textbf{Concurrency Execution Model} :
%Start of user code Concurrency Execution Model_input_Description for Solver
%End of user code 
(see section~\ref{sec:Concurrency_Execution_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_output_Description for Solver
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
\end{itemize}

\paragraph{Timesquare Solver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Timesquare_Solver}
%Start of user code Timesquare Solver

%End of user code
%Start of user code Timesquare SolverDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Timesquare_Solver.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_input_Description for Timesquare Solver
%End of user code 
(see section~\ref{sec:CCSL_Model}.)
  \item \textbf{Trigger Event Request} :
%Start of user code Trigger Event Request_input_Description for Timesquare Solver
%End of user code 
(see section~\ref{sec:Trigger_Event_Request}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_output_Description for Timesquare Solver
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
\end{itemize}




\subsection{Language Workbench}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Language_Workbench}
%Start of user code Language Workbench
%End of user code
%Start of user code Language WorkbenchDescription
A \texttt{Language Workbench} is a tool to design a language.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Language_Workbench.png}
\end{center}



\subsubsection{AS Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:AS_Compiler}
%Start of user code AS Compiler
%End of user code
%Start of user code AS CompilerDescription
An \texttt{AS Compiler} takes the specification of an \texttt{AS Model} to provide an implementation of this model.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_AS_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for AS Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_output_Description for AS Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
\end{itemize}


\subsubsection{AS Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:AS_Editor}
%Start of user code AS Editor

%End of user code
%Start of user code AS EditorDescription
An \texttt{AS Editor} is a tool to design the abstract syntax of a modeling language.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_AS_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_output_Description for AS Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

\paragraph{Ecore Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Ecore_Editor}
%Start of user code Ecore Editor

%End of user code
%Start of user code Ecore EditorDescription
The Ecore Editor is a tool to design the Ecore model of a modeling language.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Ecore_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_output_Description for Ecore Editor
This component produces an ecore model.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}



\subsubsection{Composition Operator Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Composition_Operator_Editor}
%Start of user code Composition Operator Editor
%End of user code
%Start of user code Composition Operator EditorDescription
A \texttt{Composition Operator Editor} is a tool to design a composition between two xDSMLs
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Composition_Operator_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{OperatorDefinition Model} :
%Start of user code OperatorDefinition Model_output_Description for Composition Operator Editor
%End of user code 
(see section~\ref{sec:OperatorDefinition_Model}.)
\end{itemize}


\subsubsection{Concrete Syntax Configurator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Concrete_Syntax_Configurator}
%Start of user code Concrete Syntax Configurator
%End of user code
%Start of user code Concrete Syntax ConfiguratorDescription
A \texttt{Concrete Syntax Configurator} is a tool to design a concrete syntax for a domain specific modeling language.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Concrete_Syntax_Configurator.png}
\end{center}




\subsubsection{DSA Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSA_Compiler}
%Start of user code DSA Compiler
%End of user code
%Start of user code DSA CompilerDescription
A \texttt{DSA Compiler} takes the specification of a DSA model to provide an implementation of this model.

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSA_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_input_Description for DSA Compiler
A model of DSA.
%End of user code 
(see section~\ref{sec:DSA_Model}.)
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for DSA Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code Extension} :
%Start of user code Domain Specific Metamodel Byte Code Extension_output_Description for DSA Compiler
The bytecode implementing the actions in the DSA.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code_Extension}.)
\end{itemize}

\paragraph{Kermeta Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Kermeta_Compiler}
%Start of user code Kermeta Compiler

%End of user code
%Start of user code Kermeta CompilerDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Kermeta_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_input_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Kermeta_Model}.)
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code Extension} :
%Start of user code Domain Specific Metamodel Byte Code Extension_output_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code_Extension}.)
\end{itemize}



\subsubsection{DSA Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSA_Editor}
%Start of user code DSA Editor

%End of user code
%Start of user code DSA EditorDescription
A \texttt{DSA Editor} is a tool to design \texttt{DSA Models}.
These models define the behavorial semantics of the actions in the Domain Specific Metamodel.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSA_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_output_Description for DSA Editor
%End of user code 
(see section~\ref{sec:DSA_Model}.)
\end{itemize}

\paragraph{Kermeta Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Kermeta_Editor}
%Start of user code Kermeta Editor
%End of user code
%Start of user code Kermeta EditorDescription
A \texttt{Kermeta Editor} is used in the context of GEMOC as a \texttt{DSA editor}.
\texttt{Kermeta Editor} is a tool to design \texttt{Kermeta models}. These models defines the operationnal semantics of the actions in the DSM.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Kermeta_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_output_Description for Kermeta Editor
This component produces a Kermeta model that will constitute the DSA part of Domain Specific Language according to GEMOC methodology 
%End of user code 
(see section~\ref{sec:Kermeta_Model}.)
\end{itemize}



\subsubsection{DSE Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSE_Editor}
%Start of user code DSE Editor
%End of user code
%Start of user code DSE EditorDescription
A \texttt{DSE Editor} is a tool to design \texttt{DSE Models}.
\newline To design a DSE Model, DSE Editor needs to know the model of the MOCC and the DSA associated.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSE_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_input_Description for DSE Editor
%End of user code 
(see section~\ref{sec:MOCC_Model}.)
  \item \textbf{DSA Model} :
%Start of user code DSA Model_input_Description for DSE Editor
%End of user code 
(see section~\ref{sec:DSA_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{DSE Model} :
%Start of user code DSE Model_output_Description for DSE Editor
%End of user code 
(see section~\ref{sec:DSE_Model}.)
\end{itemize}

\paragraph{ECL Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:ECL_Editor}
%Start of user code ECL Editor

%End of user code
%Start of user code ECL EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_ECL_Editor.png}
\end{center}





\subsubsection{MOCC Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:MOCC_Editor}
%Start of user code MOCC Editor
%End of user code
%Start of user code MOCC EditorDescription
A \texttt{MOCC Editor} is a tool to design a \texttt{MOCC Model} that defined operational semantics.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_MOCC_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_output_Description for MOCC Editor
%End of user code 
(see section~\ref{sec:MOCC_Model}.)
\end{itemize}

\paragraph{CCSL Library Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:CCSL_Library_Editor}
%Start of user code CCSL Library Editor

%End of user code
%Start of user code CCSL Library EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_CCSL_Library_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_output_Description for CCSL Library Editor
%End of user code 
(see section~\ref{sec:CCSL_Model}.)
\end{itemize}



\subsubsection{xDSML Design Assistant}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:xDSML_Design_Assistant}
%Start of user code xDSML Design Assistant
%End of user code
%Start of user code xDSML Design AssistantDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_xDSML_Design_Assistant.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Gemoc Project State Model} :
%Start of user code Gemoc Project State Model_input_Description for xDSML Design Assistant
%End of user code 
(see section~\ref{sec:Gemoc_Project_State_Model}.)
  \item \textbf{Gemoc Project State} :
%Start of user code Gemoc Project State_input_Description for xDSML Design Assistant
%End of user code 
(see section~\ref{sec:Gemoc_Project_State}.)
\end{itemize}




\subsection{Modeling Workbench}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Modeling_Workbench}
%Start of user code Modeling Workbench
%End of user code
%Start of user code Modeling WorkbenchDescription
A \texttt{Modeling Workbench} is a tool to run languages.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Modeling_Workbench.png}
\end{center}



\subsubsection{Model Animator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Model_Animator}
%Start of user code Model Animator
%End of user code
%Start of user code Model AnimatorDescription
A \texttt{Model Animator} is a model of a visual animation which consists to display at run time the behavior of an \texttt{Execution Model}.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Model_Animator.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_input_Description for Model Animator
%End of user code 
(see section~\ref{sec:Runtime_Controller}.)
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Model Animator
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_output_Description for Model Animator
%End of user code 
(see section~\ref{sec:Debug_User_Interface}.)
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_output_Description for Model Animator
%End of user code 
(see section~\ref{sec:Launch_Utilities}.)
  \item \textbf{Modeling Project} :
%Start of user code Modeling Project_output_Description for Model Animator
%End of user code 
(see section~\ref{sec:Modeling_Project}.)
  \item \textbf{Domain Specific Graphical Animated Editor} :
%Start of user code Domain Specific Graphical Animated Editor_output_Description for Model Animator
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animated_Editor}.)
\end{itemize}

\paragraph{Sirius Framework}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Sirius_Framework}
%Start of user code Sirius Framework

%End of user code
%Start of user code Sirius FrameworkDescription
The \href{http://www.eclipse.org/proposals/modeling.sirius/}{Sirius} framework is an Eclipse project which allows to define multi-view workbenches through graphical, table or tree modeling editors.
From the specifier/developer perspective, Sirius provides:
\begin{itemize}
\item The ability to define workbenches providing editors including diagrams, tables or trees.
\item The ability to integrate and deploy the aforementioned environment into Eclipse IDE's or RCP applications.
\item The ability to customize existing environments by specialization and extension.
\end{itemize}
From the end user perspective, Sirius provides:
\begin{itemize}
\item Rich and specialized modeling editors to design their models.
\item Synchronization between these different editors.
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Sirius_Framework.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Sirius Framework
Eclipse EMF is used to model the domain model. The meta-model describes the structure of the domain specific model.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
  \item \textbf{Domain Specific Representation Definition Model} :
%Start of user code Domain Specific Representation Definition Model_input_Description for Sirius Framework
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Model}.)
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Sirius Framework
Once the EMF meta-model is specified it is possible to generate the corresponding Java implementations classes from this model. As Sirius relies on the EMF reflexive API, it is able to work with any kind of metamodel byte code which implements this API.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_input_Description for Sirius Framework
Sirius has specific support for extending and refining diagram descriptions and mappings without modifying the original. The extensions are applied transparently when the viewpoint they are defined in are enabled, and removed when the viewpoint is disabled.  The purpose is to augment the base diagram with new graphical elements related to the animation feature.
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Extension_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animator} :
%Start of user code Domain Specific Graphical Animator_output_Description for Sirius Framework
Sirius will provide an animator integrated to the domain specific graphical editor which allows to animate and debug a model. 
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animator}.)
  \item \textbf{Domain Specific Graphical Animated Editor} :
%Start of user code Domain Specific Graphical Animated Editor_output_Description for Sirius Framework
Sirius provides a completely customized graphical editor dedicated to a domain specific languages (DSL). The graphical designers created with Sirius provide diagrams, tables, matrix or trees to create and edit models according to the domain specific vocabulary and process.
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animated_Editor}.)
\end{itemize}

\paragraph{Sirius Animator Framework}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Sirius_Animator_Framework}
%Start of user code Sirius Animator Framework

%End of user code
%Start of user code Sirius Animator FrameworkDescription
The Sirius animator framework is a part of the Sirius project which allows to animate graphical editors created with Sirius.
From the specifier/developer perspective, Sirius animator provides:
\begin{itemize}
\item The ability to customize existing environments by specialization and extension.
\end{itemize}
From the end user perspective, Sirius provides:
\begin{itemize}
\item Graphical editor enhanced with animation features.
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Sirius_Animator_Framework.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_input_Description for Sirius Animator Framework
Sirius has specific support for extending and refining diagram descriptions and mappings without modifying the original. The purpose is to augment the base diagram with new graphical elements related to the animation feature.
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Extension_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animator} :
%Start of user code Domain Specific Graphical Animator_output_Description for Sirius Animator Framework
The Sirius animator framework allows to provide to domain specific graphical editor created with Sirius the ability to animate models.
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animator}.)
\end{itemize}




\subsubsection{Model Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Model_Editor}
%Start of user code Model Editor
%End of user code
%Start of user code Model EditorDescription
A \texttt{Model Editor} is a tool to design \texttt{Domain Specific Models}.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Model_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_output_Description for Model Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

\paragraph{Sirius Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Sirius_Editor}
%Start of user code Sirius Editor
%End of user code
%Start of user code Sirius EditorDescription
The Sirius editor provides tools to specify modeling workbenches. A graphical designer allows users to create or visualize models of a given domain specific model defined with EMF (Ecore model) using the Ecore graphical designer. Then the user has to describe its graphical designer. This is done thanks to a model which is interpreted by Sirius. This model contains viewpoints which define representations (diagrams, tables, matrix and trees). Each representation defines how the model elements can be graphically represented (shape, color, font, ...) and edited (palette, tools, ...).
The Sirius editor is a graphical editor used to edit this viewpoint specification model.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Sirius_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Sirius Editor
The EMF meta-model which describes the structure of the domain specific model.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Representation Definition Model} :
%Start of user code Domain Specific Representation Definition Model_output_Description for Sirius Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Model}.)
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_output_Description for Sirius Editor
Configuration file which extends and refines existing diagram descriptions and mappings.
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Extension_Model}.)
\end{itemize}


\paragraph{Xtext}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Xtext}
%Start of user code Xtext

%End of user code
%Start of user code XtextDescription
\href{http://www.eclipse.org/Xtext}{Xtext} is an open source framework available in Eclipse for development of domain specific languages.
It covers all aspects of a complete language infrastructure, from parsers, over linker, compiler or interpreter and provides an easy way to generate textual editor fully integrated in Eclipse.
Xtext uses EMF models as the in-memory representation of any parsed text files. This in-memory object graph is called the Abstract Syntax Tree (AST).
It is possible to give to Xtext as input an existing domain specific metamodel or a grammar.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Xtext.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Xtext Grammar} :
%Start of user code Xtext Grammar_input_Description for Xtext
To create a new domain specific language with Xtext, the first thing to do is to define the grammar of the new language. The Xtext grammar language is a domain specific language designed for the description of textual languages. The main idea is to describe the concrete syntax and how it is mapped to an in-memory representation - the semantic model. This model will be produced by the parser on-the-fly when it consumes an input file.
%End of user code 
(see section~\ref{sec:Xtext_Grammar}.)
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Xtext
The domain specific metamodel from which Xtext is able to generate a textual editor. The language in which the meta model is defined is called Ecore. In this case Xtext will generate the Xtext grammar automatically based on the given metamodel.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Text Editor} :
%Start of user code Domain Text Editor_output_Description for Xtext
The generated textual editor which provides syntax coloring, content assists, validation and quick fixes fully integrated in Eclipse.
%End of user code 
(see section~\ref{sec:Domain_Text_Editor}.)
\end{itemize}




\subsection{Trace Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Trace_Editor}
%Start of user code Trace Editor
A \texttt{trace editor} takes as input a \texttt{Trace model} and allows the analysis of this trace by the user.
%End of user code
%Start of user code Trace EditorDescription
The purpose of the Trace Editor is to present different views on a trace by masking some events, highlighting relations between event occurrences in the trace (coincidence for instance) and searching for occurrence patterns (for instance, looking for all occurrences of C that follow an occurrence of A without an occurrence of B in between).
 
If the trace model supports a notion of date associated to an occurrence, the trace editor should also allow searching for sequences in a trace that have timing properties (for instance, two consecutive occurrences of A with dates separated by more than some duration).
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Trace_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_input_Description for Trace Editor
the model of the trace to be edited.
%End of user code 
(see section~\ref{sec:Trace_Model}.)
\end{itemize}



\section{Domain Specific Components}
%Start of user code DomainSpecificComponents
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/DomainSpecificComponents.jpg}
	\caption{List of the Domain Specific components}
	\label{fig:DomainSpecificComponentList}
	\end{center}
\end{figure}
A \texttt{Domains Specific Components} are components produced by the DSML designer by using the tools provided in GEMOC. The figure~\ref{fig:DomainSpecificComponentList} illustrates the point that they are output of some other component.
%End of user code
\section{Metamodels}
%Start of user code Metamodels
This section describes the metamodels used by the components in order to exchange models.
%End of user code
\subsection{CCSL Model}
\label{sec:CCSL_Model}
%Start of user code CCSL Model_interface
A \texttt{CCSL (Clock Constraint Specification Language) Model} specifies the causal and temporal relationships between the events of a DSML model
\newline A CCSL model represents the acceptable scheduling of the events of a specific DSML model, by applying the constraints from a MoCC, as specified by an ECL model.
%End of user code

\subsection{Concurrency Execution Model}
\label{sec:Concurrency_Execution_Model}
%Start of user code Concurrency Execution Model_interface

%End of user code

\subsection{DSA Model}
\label{sec:DSA_Model}
%Start of user code DSA Model_interface

%End of user code

\subsection{DSE Model}
\label{sec:DSE_Model}
%Start of user code DSE Model_interface

%End of user code

\subsection{Domain Specific Event Model}
\label{sec:Domain_Specific_Event_Model}
%Start of user code Domain Specific Event Model_interface

%End of user code

\subsection{Domain Specific Event Vector Model}
\label{sec:Domain_Specific_Event_Vector_Model}
%Start of user code Domain Specific Event Vector Model_interface

%End of user code

\subsection{Domain Specific Metamodel}
\label{sec:Domain_Specific_Metamodel}
%Start of user code Domain Specific Metamodel_interface

%End of user code

\subsection{Domain Specific Model}
\label{sec:Domain_Specific_Model}
%Start of user code Domain Specific Model_interface

%End of user code

\subsection{Domain Specific Representation Definition Extension Model}
\label{sec:Domain_Specific_Representation_Definition_Extension_Model}
%Start of user code Domain Specific Representation Definition Extension Model_interface
Sirius has specific support for extending and refining diagram descriptions and mappings without modifying the original. The purpose is to augment the base diagram with new graphical elements. In fact this metamodel is just a subpart of the domain specific representation definition metamodel.
%End of user code

\subsection{Domain Specific Representation Definition Model}
\label{sec:Domain_Specific_Representation_Definition_Model}
%Start of user code Domain Specific Representation Definition Model_interface

%End of user code

\subsection{ECL Model}
\label{sec:ECL_Model}
%Start of user code ECL Model_interface
An \texttt{ECL (Event Constraint Language) Model} is defining the link between the couple AS/DSA and the MoCC.
\newline It gets the definitions from the MoCC library and specify how they are actually used according to the AS. It also specifies (in a very crude way for now) how some events are associated to the DSA functions.
\newline It is specified at the language level.
%End of user code

\subsection{Ecore Model}
\label{sec:Ecore_Model}
%Start of user code Ecore Model_interface

%End of user code

\subsection{Execution Model}
\label{sec:Execution_Model}
%Start of user code Execution Model_interface
The Execution Model is used to describe the state of a model during its execution. This includes attributes that are used and modified by the DSA, as well as execution state attributes used by the model of computation.
%End of user code

\subsection{Gemoc Project State}
\label{sec:Gemoc_Project_State}
%Start of user code Gemoc Project State_interface

%End of user code

\subsection{Gemoc Project State Model}
\label{sec:Gemoc_Project_State_Model}
%Start of user code Gemoc Project State Model_interface
This structure is used to capture the state of the GEMOC process in the IDE. It is then used by the wizard component to drive the user in his xDSML design tasks.
%End of user code

\subsection{GemocLanguage Model}
\label{sec:GemocLanguage_Model}
%Start of user code GemocLanguage Model_interface
This structure represents the definition of a language according to GEMOC methodology.

It is composed of a DSE, a DSA and a Domain Specific Metamodel.

%End of user code

\subsection{Kermeta Model}
\label{sec:Kermeta_Model}
%Start of user code Kermeta Model_interface
In GEMOC, Kermeta language is used as a DSA.
It is able to specify the actions of a Domain Specific Metamodel.

Kermeta metamodel uses an operationnal semantics to weave the actions in the DSM.
%End of user code

\subsection{MOCC Model}
\label{sec:MOCC_Model}
%Start of user code MOCC Model_interface
%End of user code

\subsection{OperatorDefinition Model}
\label{sec:OperatorDefinition_Model}
%Start of user code OperatorDefinition Model_interface

%End of user code

\subsection{Scenario Model}
\label{sec:Scenario_Model}
%Start of user code Scenario Model_interface
The Scenario Model is used to represent input scenarios for the Scenario Policy. An input scenario contains the information needed to choose a DSE among the DSE occurrences that can occur according to the model of computation. A scenario is more abstract than a trace (which makes a difference between the Scenario Policy and the Replay Policy) and may consist in tactics like ``alternate between two choices''.
%End of user code

\subsection{Trace Model}
\label{sec:Trace_Model}
%Start of user code Trace Model_interface
The Trace Model is used to represent execution traces as sequences of domain specific event occurrences, eventually annotated with values when the behavior of the model produces data.
%End of user code

\subsection{Xtext Grammar}
\label{sec:Xtext_Grammar}
%Start of user code Xtext Grammar_interface

%End of user code


\section{Component Interfaces}
%Start of user code Component Interfaces
This section describes the interfaces used by the components.
%End of user code
\subsection{Debug User Interface}
\label{sec:Debug_User_Interface}
%Start of user code Debug User Interface_interface

%End of user code

\subsection{Domain Specific Graphical Animated Editor}
\label{sec:Domain_Specific_Graphical_Animated_Editor}
%Start of user code Domain Specific Graphical Animated Editor_interface

%End of user code

\subsection{Domain Specific Graphical Animator}
\label{sec:Domain_Specific_Graphical_Animator}
%Start of user code Domain Specific Graphical Animator_interface

%End of user code

\subsection{Domain Specific Metamodel Byte Code}
\label{sec:Domain_Specific_Metamodel_Byte_Code}
%Start of user code Domain Specific Metamodel Byte Code_interface

%End of user code

\subsection{Domain Specific Metamodel Byte Code Extension}
\label{sec:Domain_Specific_Metamodel_Byte_Code_Extension}
%Start of user code Domain Specific Metamodel Byte Code Extension_interface

%End of user code

\subsection{Domain Specific Tree Editor}
\label{sec:Domain_Specific_Tree_Editor}
%Start of user code Domain Specific Tree Editor_interface

%End of user code

\subsection{Domain Text Editor}
\label{sec:Domain_Text_Editor}
%Start of user code Domain Text Editor_interface

%End of user code

\subsection{Launch Utilities}
\label{sec:Launch_Utilities}
%Start of user code Launch Utilities_interface

%End of user code

\subsection{Modeling Project}
\label{sec:Modeling_Project}
%Start of user code Modeling Project_interface

%End of user code

\subsection{Runtime Controller}
\label{sec:Runtime_Controller}
%Start of user code Runtime Controller_interface

%End of user code

\subsection{Trigger Event Request}
\label{sec:Trigger_Event_Request}
%Start of user code Trigger Event Request_interface

%End of user code


\chapter{Component integration process}
%Start of user code Component integration process
In  order to create the GEMOC Studio, the components and metamodels must follow our development process.

\section{Providing and updating a contribution}
\subsection{Minimum requirement for a component}
A component should be integrated to the GEMOC Studio if the component :
\begin{itemize}
	\item is referenced in the GEMOC architecture model
	\item is a set of eclipse plugins/OSGI bundles
	\item has one feature referencing all plugins/bundles
	\item compiles using a maven script
	\item is deployed as a P2 repository (on Jenkins server or external URL)
	\item exposed a minimal documentation as Eclipse help (Quick start)
	\item offers a package sample (accessible through File>New>Sample in eclipse)
\end{itemize}
\subsection{Minimum requirement for a metamodel}
\begin{itemize}
	\item is referenced in the GEMOC architecture model
	\item is distributed as a part of an editor component (should follow the component minimal requirements)
\end{itemize}
\section{Continuous integration}
The resulting GEMOC Studio is available via the continuous integration server at the link below :
\newline
\url {http://ci.inria.fr/gemoc/job/org.gemoc.gemoc_studio.root/}
%End of user code

%Start of user code additionnal chapters or annexes

\newpage
\chapter{Appendix A : Tutorial "How to deliver a GEMOC Component distribution"}
This annex presents some guidelines to help the partners building the GEMOC Studio components.
\section{Sources}
\subsection{SCM}
The sources of the metamodels, components and samples developed for the project should be stored in the git repository available from the forge at link below :\newline
\url{https://gforge.inria.fr/projects/gemoc-dev/}
\newline\newline
Typical source retrieval should be done via :\newline
\textit{git clone git+ssh://yourforgelogin@scm.gforge.inria.fr/gitroot/gemoc-dev/gemoc-dev.git}
\subsection{Naming conventions}
The naming convention for a component contributions plug-in projects is the following :
\newline
\textit{\textless qualified name \textgreater.\textless component contribution name\textgreater .\textless contribution part\textgreater }
\newline

the qualified name depends to the kind of knowledge of the contributions :
\begin{itemize}
	\item New knowledge : the qualified name shall be \textbf{org} and the component contribution name shall be \textbf{gemoc} : \textit{org.gemoc} (\textit{followed by the contribution part})
	\item Appropriate knowledge : the qualified name shall be the one of partners
\end{itemize}

\subsection{Proiect organization}
\section{Continuous Integration}
The GEMOC Studio is built with the continuous integration at the link below :
\newline\url{https://ci.inria.fr/gemoc} 
\section{Update site}
All Components of the GEMOC Studio shall be provided by an update site.
\section{GEMOC Studio}
GEMOC Studio should be used to design its plug-ins which will design all along the project.

It currently contains following tools :
\begin{itemize}
	\item Mylyn
	\item M2e (maven integration for eclipse)
	\item ComponentDSL
	\item SVN/Git
	\item XML editor
	\item some EMF tools
	\item Obeo designer
	\item Kermeta2
	\item Papyrus
	\item xText
\end{itemize}
It is downloading at link below :
\newline
\url {https://ci.inria.fr/gemoc/job/org.gemoc.gemoc_studio.root/}
\section{Required configuration}
To launch GEMOC Studio, these components should setup on your computer :
\begin{itemize}
	\item JDK JAVA 1.6 minimum version, JDK should download to link below :
	\newline
	\url {http://www.oracle.com/technetwork/java/javase/downloads/index.html}
	\item Scala IDE 2.9 for juno eclipse edition, it should download to link below :
	\newline
	\url {http://download.scala-ide.org/sdk/e38/scala29/stable/site}
\end{itemize}
\section{Life-cycle of new logical component}
\subsection{Presentation of an average component life-cycle}
A new component should have some validation steps :
\begin{itemize}
	\item Compilation of the project
	\item Build with Maven
	\item The new component shaould have a quickstart documentation
	\item The new component should contain an example presenting its functionalities
\end{itemize}
\subsection{Minimum requirement for a component}
A component shall be integrated to the GEMOC studio if the component : 
\newline
\begin{itemize}
	\item is referenced in the GEMOC architecture model
	\item is a set of eclipse plugins/OSGI bundles
	\item has one feature referencing all plugins/bundles
	\item compiles using a maven script
	\item is deployed as a P2 repository (on Jenkins server or external URL)
	\item exposes a minimal documentation as Eclipse help (Quick start)
	\item offers a package sample (accessible through File\textgreater New\textgreater Sample in eclipse)
\end{itemize}

%End of user code
\end{document}
