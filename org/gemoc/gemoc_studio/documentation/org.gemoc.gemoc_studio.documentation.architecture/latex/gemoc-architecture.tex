\documentclass{gemoc} %% no option needed, default is : 10pt, twoside, babel[ english] , graphicx
\usepackage{color}

\task{4.1.1}
\title{Gemoc Architectural description}
\docnumber{D4.1.1}
\version{1.0}

\companycopyright{Consortium GEMOC}  %% Appear in the foot page

\begin{document}
\maketitle

%Start of user code revisions
\begin{revisions}
	\begin{revtable}
		\dates{}{}{}{}{}
		\writers{}{}{}{}{}
		\approvers{}{}{}{}{}
	\end{revtable}
	\begin{revisionlabels}
		\revlabel{}
	\end{revisionlabels}
\end{revisions}
%End of user code

%Start of user code tableofauthors
\begin{tableofauthors}
	\leadauthor{Didier Vojtisek}{INRIA}
	\contributor{$<$Name$>$}{$<$Organisation$>$}
\end{tableofauthors}
%End of user code

\tableofcontents
\newpage

\chapter{Introduction}
%Start of user code Introduction

%End of user code 

\section{Purpose}
%Start of user code IntroductionPurpose
This document presents the architectural design of the Gemoc Studio. We focus on 
the description of  Compoments and Metamodels integrated in the Gemoc Studio.
%End of user code

\section{Perimeter}
%Start of user code IntroductionPerimeter

%End of user code

\section{Definitions, Acronyms and Abbreviations}
%Start of user code IntroductionDefinitions
\begin{itemize}
	\item \textbf{Architecture}  : fundamental conception of a system in its environment
 embodied in its elements, their relationships between each other and to its 
environment, and the principles guiding its design and evolution
\end{itemize}
%End of user code

\section{References}
%Start of user code IntroductionReferences

%End of user code

\section{Summary}
%Start of user code IntroductionSummary

%End of user code
 
\chapter{Architecture}
%Start of user code Architecture
\begin{figure}[bt]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/Global View.jpg}
	\caption{Gemoc global view}
	\label{fig:ComponentList}
	\end{center}
\end{figure}
%End of user code

\section{Introduction}
%Start of user code ArchitectureIntroduction
\begin{figure}[bt]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, angle=90, totalheight=0.9\textheight]{../images/Logical View.jpg}
	\caption{Logical View}
	\label{fig:LogicalView}
	\end{center}
\end{figure}
\begin{figure}[bt]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, angle=90, totalheight=0.9\textheight]{../images/TimesquareImplementation.jpg}
	\caption{Timesquare implemetation view}
	\label{fig:TimesquareImplementation}
	\end{center}
\end{figure}
\begin{figure}[bt]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/All Components list.jpg}
	\caption{List of all components}
	\label{fig:AllComponentList}
	\end{center}
\end{figure}
\begin{figure}[bt]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/Gemoc Metamodels Class Diagram.jpg}
	\caption{List of metamodels}
	\label{fig:MetamodelList}
	\end{center}
\end{figure}
%End of user code

\section{Exchanges}
%Start of user code ArchitectureExchanges

%End of user code

\section{Components}
%Start of user code ArchitectureComponents

%End of user code
\subsection{Ecore Editor}
%Start of user code Ecore Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Ecore EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_output_Description for Ecore Editor
%End of user code 
\end{itemize}

\subsection{EMF Tree Editor Generator}
%Start of user code EMF Tree Editor Generator

%End of user code

\subsubsection{Purpose}
%Start of user code EMF Tree Editor GeneratorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for EMF Tree Editor Generator
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Tree Editor} :
%Start of user code Domain Specific Tree Editor_output_Description for EMF Tree Editor Generator
%End of user code 
\end{itemize}

\subsection{Xtext}
%Start of user code Xtext

%End of user code

\subsubsection{Purpose}
%Start of user code XtextDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Xtext Grammar} :
%Start of user code Xtext Grammar_input_Description for Xtext
%End of user code 
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Xtext
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Text Editor} :
%Start of user code Domain Text Editor_output_Description for Xtext
%End of user code 
\end{itemize}

\subsection{Timesquare DSA/MOCC Map Editor}
%Start of user code Timesquare DSA/MOCC Map Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Timesquare DSA/MOCC Map EditorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_input_Description for Timesquare DSA/MOCC Map Editor
%End of user code 
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_input_Description for Timesquare DSA/MOCC Map Editor
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{ECL Model} :
%Start of user code ECL Model_output_Description for Timesquare DSA/MOCC Map Editor
%End of user code 
\end{itemize}

\subsection{ECL Editor}
%Start of user code ECL Editor

%End of user code

\subsubsection{Purpose}
%Start of user code ECL EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{ECL Model} :
%Start of user code ECL Model_output_Description for ECL Editor
%End of user code 
\end{itemize}

\subsection{Kermeta Compiler}
%Start of user code Kermeta Compiler

%End of user code

\subsubsection{Purpose}
%Start of user code Kermeta CompilerDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_input_Description for Kermeta Compiler
%End of user code 
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Kermeta Compiler
%End of user code 
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Kermeta Compiler
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code Extension} :
%Start of user code Domain Specific Metamodel Byte Code Extension_output_Description for Kermeta Compiler
%End of user code 
\end{itemize}

\subsection{Timesquare Solver}
%Start of user code Timesquare Solver

%End of user code

\subsubsection{Purpose}
%Start of user code Timesquare SolverDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trigger Event Request} :
%Start of user code Trigger Event Request_input_Description for Timesquare Solver
%End of user code 
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_input_Description for Timesquare Solver
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_output_Description for Timesquare Solver
%End of user code 
\end{itemize}

\subsection{Trace Editor}
%Start of user code Trace Editor
The trace editor takes as input a trace model and allows the analysis of this trace by the user.
%End of user code

\subsubsection{Purpose}
%Start of user code Trace EditorDescription
The purpose of the Trace Editor is to present different views on a trace by masking some events, highlighting relations between event occurrences in the trace (coincidence for instance) and searching for occurrence patterns (for instance, looking for all occurrences of C that follow an occurrence of A without an occurrence of B in between).

If the trace model supports a notion of date associated to an occurrence, the trace editor should also allow searching for sequences in a trace that have timing properties (for instance, two consecutive occurrences of A with dates separated by more than some duration).
%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_input_Description for Trace Editor
  the model of the trace to be edited.
%End of user code 
\end{itemize}


\subsection{User Animation Viewer}
%Start of user code User Animation Viewer

%End of user code

\subsubsection{Purpose}
%Start of user code User Animation ViewerDescription

%End of user code 


\subsection{Gemoc Process assistant}
%Start of user code Gemoc Process assistant

%End of user code

\subsubsection{Purpose}
%Start of user code Gemoc Process assistantDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Gemoc Project State Model} :
%Start of user code Gemoc Project State Model_input_Description for Gemoc Process assistant
%End of user code 
\end{itemize}


\subsection{ModhelX}
%Start of user code ModhelX
ModHel'X is both a meta model and an execution engine for heterogeneous models which is developed at the Computer Science Department of Sup√©lec.
%End of user code

\subsubsection{Purpose}
%Start of user code ModhelXDescription
The purpose of ModHel'X is the modeling of hierarchical heterogeneous models. In order to handle heterogeneous components in a model, ModHel'X relies on a generic meta-model based on black boxes (called blocks) with observable ports (called pins). A ModHel'X model is composed of a structure (blocks with relations between their pins) and a model of computation which implements the rules for combining the behavior of the blocks as observed at their pins.

ModHel'X supports only hierarchical heterogeneity through the use of interface blocks. An interface block is a block used according to an external model of computation, and the behavior of this block is defined by a model which uses an internal model of computation. The interface block, is responsible for adapting the execution semantics between the external and the internal models of computation. This adaptation is decomposed along three axis: transforming input and output data, synchronizing the control (occurrence of events) in both models of computation, and maintaining relations between the time scales inside and outside the interface block.

For modeling the relations between the occurrence of events and the time scales in different models of computation, ModHel'X relies on a time model and a solver for these relations. This time model is called TESL (Tagged Event Specification Language) and is inspired by the Tagged Signal Model by Lee and Sangiovanni, and the CCSL language developed by the AOSTE INRIA team. Contrary to CCSL, TESL and its solver can only construct one execution trace by applying causality relations and constraints on the tags (dates) of events. It has been designed for specifying how to execute an heterogeneous model, while CCSL is more suitable to specify constraints on all possible executions of an heterogeneous model. Thanks to its reduced expressive power with regard to the ordering of events, and to its reduced analysis possibilities, TESL is able to handle constraints on the tags which are associated to event occurrences, which makes it handy and efficient for executing heterogeneous models. It would theoretically be possible to model such relations in CCSL using infinitely fast clocks. There are currently discussions about the possibility to determine if a TESL model is a correct implementation of a CCSL specification. With such a possibility, we could use CCSL for specifying a model of computation and then use TESL to write an implementation of this model of computation. The specification would allow static verification of properties, while the implementation would allow efficient simulations.

The current architecture of ModHel'X is not aligned on the Gemoc framework, and part of the contribution of Sup√©lec is to modify its structure to make it usable as an execution engine and a solver in the Gemoc framework.
%End of user code 


\subsection{NEMO}
%Start of user code NEMO

%End of user code

\subsubsection{Purpose}
%Start of user code NEMODescription

%End of user code 


\subsection{CEP Engine}
%Start of user code CEP Engine

%End of user code

\subsubsection{Purpose}
%Start of user code CEP EngineDescription

%End of user code 


\subsection{Timesquare MOCC To Execution Model}
%Start of user code Timesquare MOCC To Execution Model

%End of user code

\subsubsection{Purpose}
%Start of user code Timesquare MOCC To Execution ModelDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Timesquare MOCC To Execution Model
%End of user code 
  \item \textbf{ECL Model} :
%Start of user code ECL Model_input_Description for Timesquare MOCC To Execution Model
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_output_Description for Timesquare MOCC To Execution Model
%End of user code 
\end{itemize}

\subsection{Execution Engine}
%Start of user code Execution Engine
The Execution Engine acts on the execution state of models under the direction of the Solver and Policy.
%End of user code

\subsubsection{Purpose}
%Start of user code Execution EngineDescription
The purpose of the Execution Engine is to perform the domain specific actions (DSA) on the execution state of a model. This DSA are triggered by domain specific events (DSE) which are generated by the model of computation and selected by a policy when there are several possibilities.
%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_input_Description for Execution Engine
  the model of the events produced by the model of computation.
%End of user code 
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Execution Engine
  the model of the code that implements the DSA.
%End of user code 
  \item \textbf{Execution Model} :
%Start of user code Execution Model_input_Description for Execution Engine
    the model of the state of the model before handling the DSE by executing a DSA (current state of an automaton, current value of an attribute etc.)
%End of user code 
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_input_Description for Execution Engine
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_output_Description for Execution Engine
    the updated trace of the execution of the model after performing the DSA
%End of user code 
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_output_Description for Execution Engine
%End of user code 
  \item \textbf{Trigger Event Request} :
%Start of user code Trigger Event Request_output_Description for Execution Engine
    the requests for DSE which are consequences of the execution of DSA
%End of user code 
  \item \textbf{Execution Model} :
%Start of user code Execution Model_output_Description for Execution Engine
    the model of the state of the model after the execution of the DSA (current state of an automaton, current value of an attribute etc.)
%End of user code 
\end{itemize}

\subsection{Eclipse Debug}
%Start of user code Eclipse Debug

%End of user code

\subsubsection{Purpose}
%Start of user code Eclipse DebugDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_input_Description for Eclipse Debug
%End of user code 
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_input_Description for Eclipse Debug
%End of user code 
\end{itemize}


\subsection{Kermeta Editor}
%Start of user code Kermeta Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Kermeta EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_output_Description for Kermeta Editor
%End of user code 
\end{itemize}

\subsection{EMF Gen Model}
%Start of user code EMF Gen Model

%End of user code

\subsubsection{Purpose}
%Start of user code EMF Gen ModelDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for EMF Gen Model
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_output_Description for EMF Gen Model
%End of user code 
\end{itemize}

\subsection{Sirius Framework}
%Start of user code Sirius Framework

%End of user code

\subsubsection{Purpose}
%Start of user code Sirius FrameworkDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific  Representation Definition Model} :
%Start of user code Domain Specific  Representation Definition Model_input_Description for Sirius Framework
%End of user code 
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Sirius Framework
%End of user code 
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_input_Description for Sirius Framework
%End of user code 
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Sirius Framework
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animated Editor} :
%Start of user code Domain Specific Graphical Animated Editor_output_Description for Sirius Framework
%End of user code 
  \item \textbf{Domain Specific Graphical Animator} :
%Start of user code Domain Specific Graphical Animator_output_Description for Sirius Framework
%End of user code 
\end{itemize}

\subsection{Sirius Animator Framework}
%Start of user code Sirius Animator Framework

%End of user code

\subsubsection{Purpose}
%Start of user code Sirius Animator FrameworkDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_input_Description for Sirius Animator Framework
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animator} :
%Start of user code Domain Specific Graphical Animator_output_Description for Sirius Animator Framework
%End of user code 
\end{itemize}

\subsection{Random Policy}
%Start of user code Random Policy
The Random Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
%End of user code

\subsubsection{Purpose}
%Start of user code Random PolicyDescription
The purpose of the Random Policy is to randomly explore the possible behaviors of a model by making a random choice among all possible DSE occurrences. For instance, when executing a non deterministic automata, the random policy will randomly choose one transition among all the fireable transitions determined by the model of computation.
%End of user code 


\subsection{Scenario Policy}
%Start of user code Scenario Policy
The Scenario Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
\textcolor{red}{\textbf{FBO: A mon avis, il manque le mod√®le du scenario en input.}}
%End of user code

\subsubsection{Purpose}
%Start of user code Scenario PolicyDescription
The purpose of the Scenario Policy is to drive a simulation by choosing the DSE indicated in a scenario when several DSE when several DSE are allowed to occur according to the model of computation.
%End of user code 


\subsection{Replay Policy}
%Start of user code Replay Policy
The Replay Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
%End of user code

\subsubsection{Purpose}
%Start of user code Replay PolicyDescription
The purpose of the Replay Policy is to replay a simulation by choosing the DSE indicated in a trace model when several DSE when several DSE are allowed to occur according to the model of computation. It should also raise an error when the DSE which is indicated at a given point in the trace model is not among the DSE allowed by the model of computation (the trace model is not compatible with the behavior of the model).
%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_input_Description for Replay Policy
  the model of the trace to replay.
%End of user code 
\end{itemize}


\subsection{Policy}
%Start of user code Policy
A Policy is part of the description of the control in a language. It works in conjunction with a model of computation.
%End of user code

\subsubsection{Purpose}
%Start of user code PolicyDescription
The purpose of a Policy is to select a DSE among the possible DSE occurrences allowed by the model of computation. It can be considered as a refinement of the model of computation.
%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_input_Description for Policy
\textbf{\textcolor{red}{FBO: pas sur de bien comprendre ce qu'est le DSEVM ou bien ce qu'il fait l√†¬†. J'aurais plut√¥t dit que Policy avait besoin du Domain Specific Event Model}}
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_output_Description for Policy
%End of user code 
\end{itemize}

\subsection{Interactive Policy}
%Start of user code Interactive Policy
The Interactive Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
%End of user code

\subsubsection{Purpose}
%Start of user code Interactive PolicyDescription
The purpose of the Interactive Policy is to let the user explore the possible behaviors of a model by choosing the DSE he wants when several DSE are allowed to occur according to the model of computation.
%End of user code 


\subsection{Solver}
%Start of user code Solver

%End of user code

\subsubsection{Purpose}
%Start of user code SolverDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_input_Description for Solver
%End of user code 
  \item \textbf{Concurrency Execution Model} :
%Start of user code Concurrency Execution Model_input_Description for Solver
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_output_Description for Solver
%End of user code 
\end{itemize}

\subsection{DSA Compiler}
%Start of user code DSA Compiler

%End of user code

\subsubsection{Purpose}
%Start of user code DSA CompilerDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_input_Description for DSA Compiler
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code Extension} :
%Start of user code Domain Specific Metamodel Byte Code Extension_output_Description for DSA Compiler
%End of user code 
\end{itemize}

\subsection{Sirius Editor}
%Start of user code Sirius Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Sirius EditorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Sirius Editor
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific  Representation Definition Model} :
%Start of user code Domain Specific  Representation Definition Model_output_Description for Sirius Editor
%End of user code 
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_output_Description for Sirius Editor
%End of user code 
\end{itemize}

\subsection{Executable Modeling Tools}
%Start of user code Executable Modeling Tools

%End of user code

\subsubsection{Purpose}
%Start of user code Executable Modeling ToolsDescription

%End of user code 


\subsection{Execution Engine for Heterogeneous Models}
%Start of user code Execution Engine for Heterogeneous Models

%End of user code

\subsubsection{Purpose}
%Start of user code Execution Engine for Heterogeneous ModelsDescription

%End of user code 


\subsection{Language Definition Tools}
%Start of user code Language Definition Tools

%End of user code

\subsubsection{Purpose}
%Start of user code Language Definition ToolsDescription

%End of user code 


\subsection{Eclipse Modeling}
%Start of user code Eclipse Modeling

%End of user code

\subsubsection{Purpose}
%Start of user code Eclipse ModelingDescription

%End of user code 


\subsection{Eclipse}
%Start of user code Eclipse

%End of user code

\subsubsection{Purpose}
%Start of user code EclipseDescription

%End of user code 


\subsection{Reflexive Model Animators}
%Start of user code Reflexive Model Animators

%End of user code

\subsubsection{Purpose}
%Start of user code Reflexive Model AnimatorsDescription

%End of user code 


\subsection{MOCC Editor}
%Start of user code MOCC Editor

%End of user code

\subsubsection{Purpose}
%Start of user code MOCC EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_output_Description for MOCC Editor
%End of user code 
\end{itemize}

\subsection{DSA Editor}
%Start of user code DSA Editor

%End of user code

\subsubsection{Purpose}
%Start of user code DSA EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_output_Description for DSA Editor
%End of user code 
\end{itemize}

\subsection{AS Editor}
%Start of user code AS Editor

%End of user code

\subsubsection{Purpose}
%Start of user code AS EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_output_Description for AS Editor
%End of user code 
\end{itemize}

\subsection{CCSL Library Editor}
%Start of user code CCSL Library Editor

%End of user code

\subsubsection{Purpose}
%Start of user code CCSL Library EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_output_Description for CCSL Library Editor
%End of user code 
\end{itemize}

\subsection{DSA/MOCC Map Editor}
%Start of user code DSA/MOCC Map Editor

%End of user code

\subsubsection{Purpose}
%Start of user code DSA/MOCC Map EditorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_input_Description for DSA/MOCC Map Editor
%End of user code 
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_input_Description for DSA/MOCC Map Editor
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{DSE Model} :
%Start of user code DSE Model_output_Description for DSA/MOCC Map Editor
%End of user code 
\end{itemize}

\subsection{Language Composition tools}
%Start of user code Language Composition tools

%End of user code

\subsubsection{Purpose}
%Start of user code Language Composition toolsDescription

%End of user code 


\subsection{Composition Operator Editor}
%Start of user code Composition Operator Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Composition Operator EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{OperatorDefinition Model} :
%Start of user code OperatorDefinition Model_output_Description for Composition Operator Editor
%End of user code 
\end{itemize}

\subsection{Composition Operator Applicator}
%Start of user code Composition Operator Applicator

%End of user code

\subsubsection{Purpose}
%Start of user code Composition Operator ApplicatorDescription

%End of user code 


\subsection{Scheduling Compiler}
%Start of user code Scheduling Compiler

%End of user code

\subsubsection{Purpose}
%Start of user code Scheduling CompilerDescription

%End of user code 


\section{Domain Specific Components}
%Start of user code DomainSpecificComponents
\begin{figure}[bt]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/DomainSpecificComponents.jpg}
	\caption{List of all components}
	\label{fig:DomainSpecificComponentList}
	\end{center}
\end{figure}
%End of user code
\subsection{Domain Specific Tree Editor}
%Start of user code Domain Specific Tree Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Tree EditorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Domain Specific Tree Editor
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_output_Description for Domain Specific Tree Editor
%End of user code 
\end{itemize}

\subsection{Domain Specific Graphical Animated Editor}
%Start of user code Domain Specific Graphical Animated Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Graphical Animated EditorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_input_Description for Domain Specific Graphical Animated Editor
%End of user code 
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Domain Specific Graphical Animated Editor
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_output_Description for Domain Specific Graphical Animated Editor
%End of user code 
  \item \textbf{Modeling Project} :
%Start of user code Modeling Project_output_Description for Domain Specific Graphical Animated Editor
%End of user code 
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_output_Description for Domain Specific Graphical Animated Editor
%End of user code 
\end{itemize}

\subsection{Domain Specific Graphical Animator}
%Start of user code Domain Specific Graphical Animator

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Graphical AnimatorDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_input_Description for Domain Specific Graphical Animator
%End of user code 
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Domain Specific Graphical Animator
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_output_Description for Domain Specific Graphical Animator
%End of user code 
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_output_Description for Domain Specific Graphical Animator
%End of user code 
\end{itemize}

\subsection{Domain Specific Text Editor}
%Start of user code Domain Specific Text Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Text EditorDescription

%End of user code 


\subsection{Domain Specific Metamodel Byte Code}
%Start of user code Domain Specific Metamodel Byte Code

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Metamodel Byte CodeDescription

%End of user code 


\subsection{Domain Specific Metamodel Byte Code Extension}
%Start of user code Domain Specific Metamodel Byte Code Extension

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Metamodel Byte Code ExtensionDescription

%End of user code 


\subsection{Domain Specific Editor}
%Start of user code Domain Specific Editor

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific EditorDescription

%End of user code 

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_output_Description for Domain Specific Editor
%End of user code 
\end{itemize}

\subsection{Domain Specific Graphical Animator}
%Start of user code Domain Specific Graphical Animator

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific Graphical AnimatorDescription

%End of user code 


\subsection{Domain Specific MOCC To Execution Model}
%Start of user code Domain Specific MOCC To Execution Model

%End of user code

\subsubsection{Purpose}
%Start of user code Domain Specific MOCC To Execution ModelDescription

%End of user code 
This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSE Model} :
%Start of user code DSE Model_input_Description for Domain Specific MOCC To Execution Model
%End of user code 
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Domain Specific MOCC To Execution Model
%End of user code 
\end{itemize}

This component port requires the following outputs:
\begin{itemize}
  \item \textbf{Concurrency Execution Model} :
%Start of user code Concurrency Execution Model_output_Description for Domain Specific MOCC To Execution Model
%End of user code 
\end{itemize}

\section{Metamodels}
\subsection{DSE Model}
%Start of user code DSE Model_interface

%End of user code

\subsection{Domain Specific  Representation Definition Model}
%Start of user code Domain Specific  Representation Definition Model_interface

%End of user code

\subsection{Domain Specific Event Model}
%Start of user code Domain Specific Event Model_interface

%End of user code

\subsection{Trace Model}
%Start of user code Trace Model_interface
The Trace Model is used to represent execution traces as sequences of domain specific event occurrences, eventually annotated with values when the behavior of the model produces data.
%End of user code

\subsection{DSA Model}
%Start of user code DSA Model_interface

%End of user code

\subsection{MOCC Model}
%Start of user code MOCC Model_interface

%End of user code

\subsection{Concurrency Execution Model}
%Start of user code Concurrency Execution Model_interface

%End of user code

\subsection{Ecore Model}
%Start of user code Ecore Model_interface

%End of user code

\subsection{Domain Specific Representation Definition Extension Model}
%Start of user code Domain Specific Representation Definition Extension Model_interface

%End of user code

\subsection{Domain Specific Model}
%Start of user code Domain Specific Model_interface

%End of user code

\subsection{Domain Specific Metamodel}
%Start of user code Domain Specific Metamodel_interface

%End of user code

\subsection{ECL Model}
%Start of user code ECL Model_interface

%End of user code

\subsection{Kermeta Model}
%Start of user code Kermeta Model_interface

%End of user code

\subsection{Scenario Model}
%Start of user code Scenario Model_interface
The Scenario Model is used to represent input scenarios for the Scenario Policy. An input scenario contains the information needed to choose a DSE among the DSE occurrences that can occur according to the model of computation. A scenario is more abstract than a trace (which makes a difference between the Scenario Policy and the Replay Policy) and may consist in tactics like ``alternate between two choices''.
%End of user code

\subsection{Gemoc Project State Model}
%Start of user code Gemoc Project State Model_interface

%End of user code

\subsection{Domain Specific Event Vector Model}
%Start of user code Domain Specific Event Vector Model_interface

%End of user code

\subsection{Execution Model}
%Start of user code Execution Model_interface
The Execution Model is used to describe the state of a model during its execution. This includes attributes that are used and modified by the DSA, as well as execution state attributes used by the model of computation.
%End of user code

\subsection{GemocLanguage Model}
%Start of user code GemocLanguage Model_interface

%End of user code

\subsection{CCSL Model}
%Start of user code CCSL Model_interface

%End of user code

\subsection{OperatorDefinition Model}
%Start of user code OperatorDefinition Model_interface

%End of user code


\chapter{Component integration process}
%Start of user code Component integration process

%End of user code
\end{document}
