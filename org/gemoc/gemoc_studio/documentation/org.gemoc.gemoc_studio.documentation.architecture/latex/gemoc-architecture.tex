\documentclass{gemoc} %% no option needed, default is : 10pt, twoside, babel[ english] , graphicx
\usepackage{color}
\usepackage[colorlinks=true]{hyperref}

\task{4.1.1}
\title{Gemoc Architectural description}
\docnumber{D4.1.1}
\version{1.0}

\companycopyright{Consortium GEMOC}  %% Appear in the foot page

\begin{document}
\maketitle

%Start of user code revisions
\begin{revisions}
	\begin{revtable}
		\dates{03/06/2013}{}{}{}{}
		\writers{Didier Vojtisek}{}{}{}{}
		\approvers{Benoit Combemale}{}{}{}{}
	\end{revtable}
	\begin{revisionlabels}
		\revlabel{Initial version}
	\end{revisionlabels}
\end{revisions}
%End of user code

%Start of user code tableofauthors
\begin{tableofauthors}
	\leadauthor{Didier Vojtisek}{INRIA}
	\leadauthor{M\'elanie Bats}{OBEO}
	\contributor{All}{All}
\end{tableofauthors}
%End of user code

\tableofcontents
\newpage

\chapter{Introduction}
%Start of user code Introduction

%End of user code 

\section{Purpose}
%Start of user code IntroductionPurpose
This document presents the architectural design of the GEMOC Studio. We focus on 
the description of  Compoments and Metamodels integrated in the GEMOC Studio.
%End of user code

\section{Perimeter}
%Start of user code IntroductionPerimeter

%End of user code

\section{Definitions, Acronyms and Abbreviations}
%Start of user code IntroductionDefinitions
\begin{itemize}
	\item \textbf{Architecture}  : fundamental conception of a system in its environment
 embodied in its elements, their relationships between each other and to its 
environment, and the principles guiding its design and evolution
	\item \textbf{Architectural Description} : collection of information items used to describe an architecture
	\item \textbf{Architecture Framework} : set of common practices for ArchitecturalDescription established within a specific domain or stakeholder community
	\item \textbf{Bundle} : a group of Java classes and additional resources equipped with a detailed manifest defining the entire component, its provided and required classes
	\item \textbf{Equinox} : an implementation of the OSGi R4 specification used for the Eclipse Project
	\item \textbf{Feature} : a Feature is a deployment unit composed of several bundles
	\item \textbf{Model} : model which contributes to the convent of a View
	\item \textbf{OSGi} : OSGi is a specification of a Java based service platform one can remotely manage. The corepart of the specification is a framework that defines an application life cycle management model, a service registry, an execution environment and modules. Based on this framework, a large number of OSGi Layers, APIs and Services have been defined
	\item \textbf{Update-Site} : an update-site is an aggregation of deployment units which might be used to provision a target platform
	\item \textbf{Stakeholder} : (of a system) individual, team, organization, or classes thereof, having concerns with respect to a system 
	\item \textbf {View consistency} : relation between two Views in an ArchitecturalDescription, used to enforce consistency within the Architecture being described
	\item \textbf{View} : representation of a system from the perspective of an identified set of architecture-related concerns defined in a Viewpoint
	\item \textbf{Views consistency rule} : a contract between ViewPoints, enforced on a View consistency
	\item \textbf{ViewPoint} : conventions for the construction, interpretation and use of an architectural view and its contributing architectural models
\end{itemize}
%End of user code

\section{References}
%Start of user code IntroductionReferences
The basis of the GEMOC Studio architecture is described in the project proposal document. 
%End of user code

\section{Summary}
%Start of user code IntroductionSummary
This document describes the architecture of the GEMOC Studio, outlining every logical component along with its role and how it relates to the other components. We will detail all required and provided interfaces and define the exchanged data's format, thus describing how each individual piece of the studio is going to communicate with the others.
This document also lists the requirements regarding the technical integration of these components and guides the GEMOC partners in providing their artifacts through specific tutorials.


%End of user code
 
\chapter{Architecture}
%Start of user code Architecture
Starting from the project prososal view of the Studio (see figure \ref{fig:ProjectProposalView}), it is refined into a component based architecture as shown in figure \ref{fig:GlobalView}. 
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/ProjectProposalView.jpg}
	\caption{Project proposal view of the GEMOC Studio}
	\label{fig:ProjectProposalView}
	\end{center}
\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/Global View.jpg}
	\caption{Architecture of the GEMOC Studio}
	\label{fig:GlobalView}
	\end{center}
\end{figure}
%End of user code

\section{Introduction}
%Start of user code ArchitectureIntroduction
The logical architecture will be described with a model-based formalism describing components, input and output ports and the corresponding business entities.

We can identify 3 main groups of components and artefacts in the studio.

\begin{itemize}
	\item \textbf{GEMOC components:} are the components offered by the studio that constitutes the base of the studio and provide the main functionalities (see figures \ref{fig:LogicalView} and \ref{fig:TimesquareImplementation}).
	\item \textbf{Metamodels:} these elements are the languages used by the ``GEMOC components'' to exchange data between them. (see figure \ref{fig:MetamodelList}).
	\item \textbf{Domain Specific Components:} These artefacts are the result of some of the GEMOC components and are specific to the domain. They are produced by the Domain Designers. Then, they are used by the Domain Experts in the main process as input of other component or as a tool to produce other artefact. As they are specific to the domain, these artifacts are prefixed with ``Domain Specific''. In a real domain application, this prefix would be replaced but the actual name of the domain. (see figure \ref{fig:DomainSpecificComponentList}).
\end{itemize}

\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, angle=90, totalheight=0.9\textheight]{../images/Logical View.jpg}
	\caption{Logical View of the GEMOC Studio}
	\label{fig:LogicalView}
	\end{center}
\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, angle=90, totalheight=0.9\textheight]{../images/TimesquareImplementation.jpg}
	\caption{Implemetation view of the Execution Engine of the GEMOC Studio}
	\label{fig:TimesquareImplementation}
	\end{center}
\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/All Components list.jpg}
	\caption{List of all the components of the GEMOC Studio}
	\label{fig:AllComponentList}
	\end{center}
\end{figure}
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/Gemoc Metamodels Class Diagram.jpg}
	\caption{List of the metamodels of the GEMOC Studio}
	\label{fig:MetamodelList}
	\end{center}
\end{figure}
%End of user code


\section{Components}
%Start of user code ArchitectureComponents

%End of user code
\subsection{AS Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:AS_Editor}
%Start of user code AS Editor

%End of user code
%Start of user code AS EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_AS_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_output_Description for AS Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

\subsubsection{Ecore Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Ecore_Editor}
%Start of user code Ecore Editor

%End of user code
%Start of user code Ecore EditorDescription
This component allows to create and edit an ecore model in order to specify the DSML domain concepts as planned by the WP1 process.
\begin{figure}[h]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/EcoreDiagramOverview.png}
	\caption{Ecore editor screenshot}
	\end{center}
\end{figure}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Ecore_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_output_Description for Ecore Editor
This component produces an ecore model.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}



\subsection{CEP Engine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:CEP_Engine}
%Start of user code CEP Engine

%End of user code
%Start of user code CEP EngineDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_CEP_Engine.png}
\end{center}




\subsection{Composition Operator Applicator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Composition_Operator_Applicator}
%Start of user code Composition Operator Applicator
%End of user code
%Start of user code Composition Operator ApplicatorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Composition_Operator_Applicator.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{OperatorDefinition Model} :
%Start of user code OperatorDefinition Model_input_Description for Composition Operator Applicator
%End of user code 
(see section~\ref{sec:OperatorDefinition_Model}.)
\end{itemize}



\subsection{Composition Operator Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Composition_Operator_Editor}
%Start of user code Composition Operator Editor
%End of user code
%Start of user code Composition Operator EditorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Composition_Operator_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{OperatorDefinition Model} :
%Start of user code OperatorDefinition Model_output_Description for Composition Operator Editor
%End of user code 
(see section~\ref{sec:OperatorDefinition_Model}.)
\end{itemize}


\subsection{EMF Tree Editor Generator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:EMF_Tree_Editor_Generator}
%Start of user code EMF Tree Editor Generator

%End of user code
%Start of user code EMF Tree Editor GeneratorDescription
This component is in charge of generating a Domain Specific Editor. More specifically it generates a tree editor component for the xDSML. 

Eclipse Modeling Framework provides such component. It uses the Domain Specific metamodel provided as an ecore model and a genmodel configuration.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_EMF_Tree_Editor_Generator.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for EMF Tree Editor Generator
An ecore model representing the domain concepts of the user DSML.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Tree Editor} :
%Start of user code Domain Specific Tree Editor_output_Description for EMF Tree Editor Generator
This component produces a new component that we will reference as \emph{Domain Specific Tree Editor}.
%End of user code 
(see section~\ref{sec:Domain_Specific_Tree_Editor}.)
\end{itemize}


\subsection{Eclipse}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Eclipse}
%Start of user code Eclipse
Eclipse is an integrated development environment composed of a runtime system and an plug-in mechanism used to extend and customize the environment. It is released under the terms of the Eclipse Public License, and is a free and open source software. The GEMOC studio will be based on and fully integrated to Eclipse. Consequently most of the end user GEMOC components will be released as Eclipse plugins.
%End of user code
%Start of user code EclipseDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Eclipse.png}
\end{center}




\subsection{Eclipse Debug}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Eclipse_Debug}
%Start of user code Eclipse Debug

%End of user code
%Start of user code Eclipse DebugDescription
The Debug component of the Eclipse platform defines language independent facilities and mechanisms for:
\begin{itemize}
\item Launching programs
\item Source lookup
\item Defining and registering breakpoints
\item Event notification from programs being debugged
\item A language independent debug model
\item A language independent debug UI
\end{itemize}

The Eclipse debugger allows to control the execution process of a program interactively while watching the source code and the variables during the execution. It is possible to stop the execution on a specific element by defining breakpoints. When the program is paused, it is possible to see the variables current states and change their values.
\begin{figure}[h]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/EclipseDebugPerspective.png}
	\caption{Eclipse Debug screenshot}
	\end{center}
\end{figure}

Eclipse provides a special Debug perspective with default views and actions available:
\begin{itemize}
\item Set/Unset \textbf{breakpoints}
\item \textbf{Start} and \textbf{Stop} the debugger
\item Control the program execution : \textbf{Step into}, \textbf{Step over}, \textbf{Step out} and \textbf{Resume}
\item See the \textbf{Call Stack}
\item \textbf{Variables} view : display variables from the current executing stack and change the values assigned to a variable
\item \textbf{Expressions} view : get the current value of an expression from the current executing stack
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Eclipse_Debug.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_input_Description for Eclipse Debug
JAVA API to add launch configuration types to the platform. A launch configuration is a description of how to launch a program. Launching in Eclipse is closely tied to the infrastructure for debugging.
%End of user code 
(see section~\ref{sec:Launch_Utilities}.)
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_input_Description for Eclipse Debug
Java API to provide a new debugging framework. It defines interfaces for a language independent debug model, which abstract common debugging features of many languages. 
%End of user code 
(see section~\ref{sec:Debug_User_Interface}.)
\end{itemize}



\subsection{Eclipse Modeling}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Eclipse_Modeling}
%Start of user code Eclipse Modeling

%End of user code
%Start of user code Eclipse ModelingDescription
The Eclipse Modeling Project focuses on the evolution and promotion of model-based development technologies within the Eclipse community by providing a unified set of modeling frameworks, tooling, and standards implementations. The GEMOC Studio is based on many different Eclipse modeling projects :
\begin{itemize}
\item EMF : a modeling framework and code generation facility for building tools and other applications based on a structured data model.
\item GEF : provides technology to create rich graphical editors and views for the Eclipse Workbench UI.
\item GMF : an application framework for creating graphical editors using EMF and GEF.
\item Sirius : a framework which provides specific multi-view workbenches through graphical, table or tree modeling editors.
\item Xtext : a framework/tool for developing external textual DSLs based on EMF.
\item Unified Modeling Language 2.x : an EMF-based implementation of the UML 2.x metamodel for the Eclipse platform.
\item Acceleo : a template based code generation framework with high quality tooling : complete Editor, Debugger and Profiler.
\item ...
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Eclipse_Modeling.png}
\end{center}




\subsection{Execution Engine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Execution_Engine}
%Start of user code Execution Engine

%End of user code
%Start of user code Execution EngineDescription
The Execution Engine acts on the execution state of models under the direction of the Solver and Policy.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Execution_Engine.png}
\end{center}



\subsubsection{Composition Operator Applicator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Composition_Operator_Applicator}
%Start of user code Composition Operator Applicator
%End of user code
%Start of user code Composition Operator ApplicatorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Composition_Operator_Applicator.png}
\end{center}




\subsubsection{DSE Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSE_Compiler}
%Start of user code DSE Compiler
%End of user code
%Start of user code DSE CompilerDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSE_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for DSE Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
  \item \textbf{DSE Model} :
%Start of user code DSE Model_input_Description for DSE Compiler
%End of user code 
(see section~\ref{sec:DSE_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Concurrency Execution Model} :
%Start of user code Concurrency Execution Model_output_Description for DSE Compiler
%End of user code 
(see section~\ref{sec:Concurrency_Execution_Model}.)
\end{itemize}

\paragraph{Timesquare MOCC To Execution Model}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Timesquare_MOCC_To_Execution_Model}
%Start of user code Timesquare MOCC To Execution Model

%End of user code
%Start of user code Timesquare MOCC To Execution ModelDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Timesquare_MOCC_To_Execution_Model.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{ECL Model} :
%Start of user code ECL Model_input_Description for Timesquare MOCC To Execution Model
%End of user code 
(see section~\ref{sec:ECL_Model}.)
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Timesquare MOCC To Execution Model
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_output_Description for Timesquare MOCC To Execution Model
%End of user code 
(see section~\ref{sec:CCSL_Model}.)
\end{itemize}



\subsubsection{DSE Engine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSE_Engine}
%Start of user code DSE Engine
%End of user code
%Start of user code DSE EngineDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSE_Engine.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Model}.)
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
  \item \textbf{Execution Model} :
%Start of user code Execution Model_input_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Execution_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Trace_Model}.)
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Runtime_Controller}.)
  \item \textbf{Trigger Event Request} :
%Start of user code Trigger Event Request_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Trigger_Event_Request}.)
  \item \textbf{Execution Model} :
%Start of user code Execution Model_output_Description for DSE Engine
%End of user code 
(see section~\ref{sec:Execution_Model}.)
\end{itemize}


\subsubsection{MOCC Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:MOCC_Compiler}
%Start of user code MOCC Compiler
%End of user code
%Start of user code MOCC CompilerDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_MOCC_Compiler.png}
\end{center}




\subsubsection{Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Policy}
%Start of user code Policy
A Policy is part of the description of the control in a language. It works in conjunction with a model of computation.
The Policy component is an abstract componant whose implementations are responsible for selecting one Domain Specific Event from a vector of triggerable Domain Specific Event. Several selection strategies are provided in GEMOC.
%End of user code
%Start of user code PolicyDescription
The purpose of a Policy is to select a DSE among the possible DSE occurrences allowed by the model of computation. It can be considered as a refinement of the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Policy.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_input_Description for Policy
\textbf{\textcolor{red}{FBO: pas sur de bien comprendre ce qu'est le DSEVM ou bien ce qu'il fait l\`a. J'aurais plut\^ot dit que Policy avait besoin du Domain Specific Event Model}}
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_output_Description for Policy
The Policy component provides one Domain Specific Event selected out of the triggerable set.
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Model}.)
\end{itemize}


\subsubsection{Solver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Solver}
%Start of user code Solver

%End of user code
%Start of user code SolverDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Solver.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Model} :
%Start of user code Domain Specific Event Model_input_Description for Solver
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Model}.)
  \item \textbf{} :
%Start of user code _input_Description for Solver
%End of user code 
(see section~\ref{sec:}.)
  \item \textbf{Concurrency Execution Model} :
%Start of user code Concurrency Execution Model_input_Description for Solver
%End of user code 
(see section~\ref{sec:Concurrency_Execution_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_output_Description for Solver
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
\end{itemize}

\paragraph{Timesquare Solver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Timesquare_Solver}
%Start of user code Timesquare Solver

%End of user code
%Start of user code Timesquare SolverDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Timesquare_Solver.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_input_Description for Timesquare Solver
%End of user code 
(see section~\ref{sec:CCSL_Model}.)
  \item \textbf{Trigger Event Request} :
%Start of user code Trigger Event Request_input_Description for Timesquare Solver
%End of user code 
(see section~\ref{sec:Trigger_Event_Request}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Event Vector Model} :
%Start of user code Domain Specific Event Vector Model_output_Description for Timesquare Solver
%End of user code 
(see section~\ref{sec:Domain_Specific_Event_Vector_Model}.)
\end{itemize}




\subsection{Gemoc Process assistant}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Gemoc_Process_assistant}
%Start of user code Gemoc Process assistant

%End of user code
%Start of user code Gemoc Process assistantDescription
This component aims at proposing some guidance to the user in order to follow the GEMOC methodology. This component may be some kind of integrated tutorial and/or process wizard.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Gemoc_Process_assistant.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Gemoc Project State Model} :
%Start of user code Gemoc Project State Model_input_Description for Gemoc Process assistant
If the component is presented as a wizard, it may take as input the current state of the current GEMOC project (GemocProjectState) so it can highlight the current step and propose the next steps to the user.
%End of user code 
(see section~\ref{sec:Gemoc_Project_State_Model}.)
  \item \textbf{Gemoc Project State} :
%Start of user code Gemoc Project State_input_Description for Gemoc Process assistant
%End of user code 
(see section~\ref{sec:Gemoc_Project_State}.)
\end{itemize}



\subsection{Interactive Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Interactive_Policy}
%Start of user code Interactive Policy
The Interactive Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
It inherits from Policy component and have all its input/outputs.
%End of user code
%Start of user code Interactive PolicyDescription
The purpose of the Interactive Policy is to let the user explore the possible behaviors of a model by choosing the DSE he wants when several DSE are allowed to occur according to the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Interactive_Policy.png}
\end{center}




\subsection{Language Workbench}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Language_Workbench}
%Start of user code Language Workbench
%End of user code
%Start of user code Language WorkbenchDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Language_Workbench.png}
\end{center}



\subsubsection{AS Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:AS_Compiler}
%Start of user code AS Compiler
%End of user code
%Start of user code AS CompilerDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_AS_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for AS Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_output_Description for AS Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
\end{itemize}


\subsubsection{Composition Operator Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Composition_Operator_Editor}
%Start of user code Composition Operator Editor
%End of user code
%Start of user code Composition Operator EditorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Composition_Operator_Editor.png}
\end{center}




\subsubsection{Concrete Syntax Configurator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Concrete_Syntax_Configurator}
%Start of user code Concrete Syntax Configurator
%End of user code
%Start of user code Concrete Syntax ConfiguratorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Concrete_Syntax_Configurator.png}
\end{center}




\subsubsection{DSA Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSA_Compiler}
%Start of user code DSA Compiler
%End of user code
%Start of user code DSA CompilerDescription
The DSA compiler is in charge of taking a model a DSA and produce the bytecode that implement the corresponding actions.

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSA_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_input_Description for DSA Compiler
A model of DSA.
%End of user code 
(see section~\ref{sec:DSA_Model}.)
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for DSA Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code Extension} :
%Start of user code Domain Specific Metamodel Byte Code Extension_output_Description for DSA Compiler
The bytecode implementing the actions in the DSA.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code_Extension}.)
\end{itemize}

\paragraph{Kermeta Compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Kermeta_Compiler}
%Start of user code Kermeta Compiler

%End of user code
%Start of user code Kermeta CompilerDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Kermeta_Compiler.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_input_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Kermeta_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel Byte Code Extension} :
%Start of user code Domain Specific Metamodel Byte Code Extension_output_Description for Kermeta Compiler
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code_Extension}.)
\end{itemize}



\subsubsection{DSA Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSA_Editor}
%Start of user code DSA Editor

%End of user code
%Start of user code DSA EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSA_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_output_Description for DSA Editor
%End of user code 
(see section~\ref{sec:DSA_Model}.)
\end{itemize}

\paragraph{Kermeta Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Kermeta_Editor}
%Start of user code Kermeta Editor
Kermeta Editor is used in the context of GEMOC as a DSA editor.
%End of user code
%Start of user code Kermeta EditorDescription
Kermeta Editor allows to create and edit kermeta models. These models defines the operationnal semantics of the actions in the DSM.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Kermeta_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Kermeta Model} :
%Start of user code Kermeta Model_output_Description for Kermeta Editor
This component produces a Kermeta model that will constitute the DSA part of Domain Specific Language according to GEMOC methodology 
%End of user code 
(see section~\ref{sec:Kermeta_Model}.)
\end{itemize}



\subsubsection{DSE Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:DSE_Editor}
%Start of user code DSE Editor
%End of user code
%Start of user code DSE EditorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_DSE_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{DSA Model} :
%Start of user code DSA Model_input_Description for DSE Editor
%End of user code 
(see section~\ref{sec:DSA_Model}.)
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_input_Description for DSE Editor
%End of user code 
(see section~\ref{sec:MOCC_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{DSE Model} :
%Start of user code DSE Model_output_Description for DSE Editor
%End of user code 
(see section~\ref{sec:DSE_Model}.)
\end{itemize}

\paragraph{ECL Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:ECL_Editor}
%Start of user code ECL Editor

%End of user code
%Start of user code ECL EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_ECL_Editor.png}
\end{center}





\subsubsection{MOCC Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:MOCC_Editor}
%Start of user code MOCC Editor

%End of user code
%Start of user code MOCC EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_MOCC_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{MOCC Model} :
%Start of user code MOCC Model_output_Description for MOCC Editor
%End of user code 
(see section~\ref{sec:MOCC_Model}.)
\end{itemize}

\paragraph{CCSL Library Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:CCSL_Library_Editor}
%Start of user code CCSL Library Editor

%End of user code
%Start of user code CCSL Library EditorDescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_CCSL_Library_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{CCSL Model} :
%Start of user code CCSL Model_output_Description for CCSL Library Editor
%End of user code 
(see section~\ref{sec:CCSL_Model}.)
\end{itemize}




\subsection{Modeling Workbench}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Modeling_Workbench}
%Start of user code Modeling Workbench
%End of user code
%Start of user code Modeling WorkbenchDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Modeling_Workbench.png}
\end{center}



\subsubsection{Model Animator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Model_Animator}
%Start of user code Model Animator
%End of user code
%Start of user code Model AnimatorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Model_Animator.png}
\end{center}




\subsubsection{Model Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Model_Editor}
%Start of user code Model Editor
%End of user code
%Start of user code Model EditorDescription
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Model_Editor.png}
\end{center}


This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_output_Description for Model Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

\paragraph{Sirius Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Sirius_Editor}
%Start of user code Sirius Editor
%End of user code
%Start of user code Sirius EditorDescription
The Sirius editor provides tools to specify modeling workbenches. A graphical designer allows users to create or visualize models of a given domain specific model defined with EMF (Ecore model) using the Ecore graphical designer. Then the user has to describe its graphical designer. This is done thanks to a model which is interpreted by Sirius. This model contains viewpoints which define representations (diagrams, tables, matrix and trees). Each representation defines how the model elements can be graphically represented (shape, color, font, ...) and edited (palette, tools, ...).
The Sirius editor is a graphical editor used to edit this viewpoint specification model.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Sirius_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Sirius Editor
The EMF meta-model which describes the structure of the domain specific model.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_output_Description for Sirius Editor
Configuration file which extends and refines existing diagram descriptions and mappings.
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Extension_Model}.)
  \item \textbf{Domain Specific Representation Definition Model} :
%Start of user code Domain Specific Representation Definition Model_output_Description for Sirius Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Model}.)
\end{itemize}




\subsection{NEMO}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:NEMO}
%Start of user code NEMO

%End of user code
%Start of user code NEMODescription

%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_NEMO.png}
\end{center}




\subsection{Random Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Random_Policy}
%Start of user code Random Policy
The Random Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
%End of user code
%Start of user code Random PolicyDescription
The purpose of the Random Policy is to randomly explore the possible behaviors of a model by making a random choice among all possible DSE occurrences. For instance, when executing a non deterministic automata, the random policy will randomly choose one transition among all the fireable transitions determined by the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Random_Policy.png}
\end{center}




\subsection{Replay Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Replay_Policy}
%Start of user code Replay Policy
The Replay Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
It inherits from Policy component and have all its input/outputs.
%End of user code
%Start of user code Replay PolicyDescription
The purpose of the Replay Policy is to replay a simulation by choosing the DSE indicated in a trace model when several DSE when several DSE are allowed to occur according to the model of computation. It should also raise an error when the DSE which is indicated at a given point in the trace model is not among the DSE allowed by the model of computation (the trace model is not compatible with the behavior of the model).
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Replay_Policy.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_input_Description for Replay Policy
the model of the trace to replay.
%End of user code 
(see section~\ref{sec:Trace_Model}.)
\end{itemize}



\subsection{Scenario Policy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Scenario_Policy}
%Start of user code Scenario Policy
The Scenario Policy is a policy for selecting a DSE among the all the DSE that are allowed to occur according to the model of computation.
\textcolor{red}{\textbf{FBO: A mon avis, il manque le modele du scenario en input.}}
It inherits from Policy component and have all its input/outputs.
%End of user code
%Start of user code Scenario PolicyDescription
The purpose of the Scenario Policy is to drive a simulation by choosing the DSE indicated in a scenario when several DSE when several DSE are allowed to occur according to the model of computation.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Scenario_Policy.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Scenario Model} :
%Start of user code Scenario Model_input_Description for Scenario Policy
%End of user code 
(see section~\ref{sec:Scenario_Model}.)
\end{itemize}



\subsection{Sirius Framework}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Sirius_Framework}
%Start of user code Sirius Framework

%End of user code
%Start of user code Sirius FrameworkDescription
The \href{http://www.eclipse.org/proposals/modeling.sirius/}{Sirius} framework is an Eclipse project which allows to define multi-view workbenches through graphical, table or tree modeling editors.
From the specifier/developer perspective, Sirius provides:
\begin{itemize}
\item The ability to define workbenches providing editors including diagrams, tables or trees.
\item The ability to integrate and deploy the aforementioned environment into Eclipse IDE's or RCP applications.
\item The ability to customize existing environments by specialization and extension.
\end{itemize}
From the end user perspective, Sirius provides:
\begin{itemize}
\item Rich and specialized modeling editors to design their models.
\item Synchronization between these different editors.
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Sirius_Framework.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Sirius Framework
Eclipse EMF is used to model the domain model. The meta-model describes the structure of the domain specific model.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_input_Description for Sirius Framework
Sirius has specific support for extending and refining diagram descriptions and mappings without modifying the original. The extensions are applied transparently when the viewpoint they are defined in are enabled, and removed when the viewpoint is disabled.  The purpose is to augment the base diagram with new graphical elements related to the animation feature.
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Extension_Model}.)
  \item \textbf{Domain Specific Metamodel Byte Code} :
%Start of user code Domain Specific Metamodel Byte Code_input_Description for Sirius Framework
Once the EMF meta-model is specified it is possible to generate the corresponding Java implementations classes from this model. As Sirius relies on the EMF reflexive API, it is able to work with any kind of metamodel byte code which implements this API.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel_Byte_Code}.)
  \item \textbf{Domain Specific Representation Definition Model} :
%Start of user code Domain Specific Representation Definition Model_input_Description for Sirius Framework
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animator} :
%Start of user code Domain Specific Graphical Animator_output_Description for Sirius Framework
Sirius will provide an animator integrated to the domain specific graphical editor which allows to animate and debug a model. 
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animator}.)
  \item \textbf{Domain Specific Graphical Animated Editor} :
%Start of user code Domain Specific Graphical Animated Editor_output_Description for Sirius Framework
Sirius provides a completely customized graphical editor dedicated to a domain specific languages (DSL). The graphical designers created with Sirius provide diagrams, tables, matrix or trees to create and edit models according to the domain specific vocabulary and process.
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animated_Editor}.)
\end{itemize}

\subsubsection{Sirius Animator Framework}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Sirius_Animator_Framework}
%Start of user code Sirius Animator Framework

%End of user code
%Start of user code Sirius Animator FrameworkDescription
The Sirius animator framework is a part of the Sirius project which allows to animate graphical editors created with Sirius.
From the specifier/developer perspective, Sirius animator provides:
\begin{itemize}
\item The ability to customize existing environments by specialization and extension.
\end{itemize}
From the end user perspective, Sirius provides:
\begin{itemize}
\item Graphical editor enhanced with animation features.
\end{itemize}
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Sirius_Animator_Framework.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Representation Definition Extension Model} :
%Start of user code Domain Specific Representation Definition Extension Model_input_Description for Sirius Animator Framework
Sirius has specific support for extending and refining diagram descriptions and mappings without modifying the original. The purpose is to augment the base diagram with new graphical elements related to the animation feature.
%End of user code 
(see section~\ref{sec:Domain_Specific_Representation_Definition_Extension_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animator} :
%Start of user code Domain Specific Graphical Animator_output_Description for Sirius Animator Framework
The Sirius animator framework allows to provide to domain specific graphical editor created with Sirius the ability to animate models.
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animator}.)
\end{itemize}



\subsection{Trace Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Trace_Editor}
%Start of user code Trace Editor
The trace editor takes as input a trace model and allows the analysis of this trace by the user.
%End of user code
%Start of user code Trace EditorDescription
The purpose of the Trace Editor is to present different views on a trace by masking some events, highlighting relations between event occurrences in the trace (coincidence for instance) and searching for occurrence patterns (for instance, looking for all occurrences of C that follow an occurrence of A without an occurrence of B in between).
 
If the trace model supports a notion of date associated to an occurrence, the trace editor should also allow searching for sequences in a trace that have timing properties (for instance, two consecutive occurrences of A with dates separated by more than some duration).
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Trace_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Trace Model} :
%Start of user code Trace Model_input_Description for Trace Editor
the model of the trace to be edited.
%End of user code 
(see section~\ref{sec:Trace_Model}.)
\end{itemize}



\subsection{Xtext}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Xtext}
%Start of user code Xtext

%End of user code
%Start of user code XtextDescription
\href{http://www.eclipse.org/Xtext}{Xtext} is an open source framework available in Eclipse for development of domain specific languages.
It covers all aspects of a complete language infrastructure, from parsers, over linker, compiler or interpreter and provides an easy way to generate textual editor fully integrated in Eclipse.
Xtext uses EMF models as the in-memory representation of any parsed text files. This in-memory object graph is called the Abstract Syntax Tree (AST).
It is possible to give to Xtext as input an existing domain specific metamodel or a grammar.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Xtext.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Domain Specific Metamodel} :
%Start of user code Domain Specific Metamodel_input_Description for Xtext
The domain specific metamodel from which Xtext is able to generate a textual editor. The language in which the meta model is defined is called Ecore. In this case Xtext will generate the Xtext grammar automatically based on the given metamodel.
%End of user code 
(see section~\ref{sec:Domain_Specific_Metamodel}.)
  \item \textbf{Xtext Grammar} :
%Start of user code Xtext Grammar_input_Description for Xtext
To create a new domain specific language with Xtext, the first thing to do is to define the grammar of the new language. The Xtext grammar language is a domain specific language designed for the description of textual languages. The main idea is to describe the concrete syntax and how it is mapped to an in-memory representation - the semantic model. This model will be produced by the parser on-the-fly when it consumes an input file.
%End of user code 
(see section~\ref{sec:Xtext_Grammar}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Text Editor} :
%Start of user code Domain Text Editor_output_Description for Xtext
The generated textual editor which provides syntax coloring, content assists, validation and quick fixes fully integrated in Eclipse.
%End of user code 
(see section~\ref{sec:Domain_Text_Editor}.)
\end{itemize}


\section{Domain Specific Components}
%Start of user code DomainSpecificComponents
\begin{figure}[htp]
	\begin{center}
	\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true, width=1.0\linewidth]{../images/DomainSpecificComponents.jpg}
	\caption{List of the Domain Specific components}
	\label{fig:DomainSpecificComponentList}
	\end{center}
\end{figure}
The Domains Specific Components are components produced by the DSML designer by using the tools provided in GEMOC. The figure~\ref{fig:DomainSpecificComponentList} illustrates the point that they are output of some other component.
%End of user code
\subsection{Domain Specific Graphical Animated Editor}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:Domain_Specific_Graphical_Animated_Editor}
%Start of user code Domain Specific Graphical Animated Editor

%End of user code
%Start of user code Domain Specific Graphical Animated EditorDescription
Sirius provides a completely customized graphical editor dedicated to a domain specific languages (DSL). The graphical designers created with Sirius
provide diagrams, tables, matrix or trees to create and edit models according to the domain specific vocabulary and process.
%End of user code 
\begin{center}
\includegraphics*[trim=0.0cm 0.0cm 0cm 0.0cm, clip=true]{../images/generated/Generated_Domain_Specific_Graphical_Animated_Editor.png}
\end{center}

This component port requires the following inputs:
\begin{itemize}
  \item \textbf{Runtime Controller} :
%Start of user code Runtime Controller_input_Description for Domain Specific Graphical Animated Editor
This interface allows the integration with the Eclipse Debug component. This interfaces is detailed in the Domain Specific Graphical Animator section.
%End of user code 
(see section~\ref{sec:Runtime_Controller}.)
  \item \textbf{Domain Specific Model} :
%Start of user code Domain Specific Model_input_Description for Domain Specific Graphical Animated Editor
Instance of the domain specific metamodel.
%End of user code 
(see section~\ref{sec:Domain_Specific_Model}.)
\end{itemize}

This component port provides the following outputs:
\begin{itemize}
  \item \textbf{Domain Specific Graphical Animated Editor} :
%Start of user code Domain Specific Graphical Animated Editor_output_Description for Domain Specific Graphical Animated Editor
%End of user code 
(see section~\ref{sec:Domain_Specific_Graphical_Animated_Editor}.)
  \item \textbf{Modeling Project} :
%Start of user code Modeling Project_output_Description for Domain Specific Graphical Animated Editor
Sirius provides a runtime that works with models within the Eclipse IDE, providing the notion of \em{Modeling Project}, an integration with the Project Explorer, handling the synchronization of workspace resources and in memory instances and the sharing of command stacks and editing domains across editors.
%End of user code 
(see section~\ref{sec:Modeling_Project}.)
  \item \textbf{Debug User Interface} :
%Start of user code Debug User Interface_output_Description for Domain Specific Graphical Animated Editor
The Eclipse Debug classical interface.
%End of user code 
(see section~\ref{sec:Debug_User_Interface}.)
  \item \textbf{Launch Utilities} :
%Start of user code Launch Utilities_output_Description for Domain Specific Graphical Animated Editor
The Eclipse launch framework.
%End of user code 
(see section~\ref{sec:Launch_Utilities}.)
\end{itemize}


\section{Metamodels}
\subsection{CCSL Model}
\label{sec:CCSL_Model}
%Start of user code CCSL Model_interface

%End of user code

\subsection{Concurrency Execution Model}
\label{sec:Concurrency_Execution_Model}
%Start of user code Concurrency Execution Model_interface

%End of user code

\subsection{DSA Model}
\label{sec:DSA_Model}
%Start of user code DSA Model_interface

%End of user code

\subsection{DSE Model}
\label{sec:DSE_Model}
%Start of user code DSE Model_interface

%End of user code

\subsection{Domain Specific Event Model}
\label{sec:Domain_Specific_Event_Model}
%Start of user code Domain Specific Event Model_interface

%End of user code

\subsection{Domain Specific Event Vector Model}
\label{sec:Domain_Specific_Event_Vector_Model}
%Start of user code Domain Specific Event Vector Model_interface

%End of user code

\subsection{Domain Specific Metamodel}
\label{sec:Domain_Specific_Metamodel}
%Start of user code Domain Specific Metamodel_interface

%End of user code

\subsection{Domain Specific Model}
\label{sec:Domain_Specific_Model}
%Start of user code Domain Specific Model_interface

%End of user code

\subsection{Domain Specific Representation Definition Extension Model}
\label{sec:Domain_Specific_Representation_Definition_Extension_Model}
%Start of user code Domain Specific Representation Definition Extension Model_interface
Sirius has specific support for extending and refining diagram descriptions and mappings without modifying the original. The purpose is to augment the base diagram with new graphical elements. In fact this metamodel is just a subpart of the domain specific representation definition metamodel.
%End of user code

\subsection{Domain Specific Representation Definition Model}
\label{sec:Domain_Specific_Representation_Definition_Model}
%Start of user code Domain Specific Representation Definition Model_interface

%End of user code

\subsection{ECL Model}
\label{sec:ECL_Model}
%Start of user code ECL Model_interface

%End of user code

\subsection{Ecore Model}
\label{sec:Ecore_Model}
%Start of user code Ecore Model_interface

%End of user code

\subsection{Execution Model}
\label{sec:Execution_Model}
%Start of user code Execution Model_interface
The Execution Model is used to describe the state of a model during its execution. This includes attributes that are used and modified by the DSA, as well as execution state attributes used by the model of computation.
%End of user code

\subsection{Gemoc Project State Model}
\label{sec:Gemoc_Project_State_Model}
%Start of user code Gemoc Project State Model_interface
This structure is used to capture the state of the GEMOC process in the IDE. It is then used by the wizard component to drive the user in his xDSML design tasks.
%End of user code

\subsection{GemocLanguage Model}
\label{sec:GemocLanguage_Model}
%Start of user code GemocLanguage Model_interface
This structure represents the definition of a language according to GEMOC methodology.

It is composed of a DSE, a DSA and a Domain Specific Metamodel.

%End of user code

\subsection{Kermeta Model}
\label{sec:Kermeta_Model}
%Start of user code Kermeta Model_interface
In GEMOC, Kermeta language is used as a DSA.
It is able to specify the actions of a Domain Specific Metamodel.

Kermeta metamodel uses an operationnal semantics to weave the actions in the DSM.
%End of user code

\subsection{MOCC Model}
\label{sec:MOCC_Model}
%Start of user code MOCC Model_interface

%End of user code

\subsection{OperatorDefinition Model}
\label{sec:OperatorDefinition_Model}
%Start of user code OperatorDefinition Model_interface

%End of user code

\subsection{Scenario Model}
\label{sec:Scenario_Model}
%Start of user code Scenario Model_interface
The Scenario Model is used to represent input scenarios for the Scenario Policy. An input scenario contains the information needed to choose a DSE among the DSE occurrences that can occur according to the model of computation. A scenario is more abstract than a trace (which makes a difference between the Scenario Policy and the Replay Policy) and may consist in tactics like ``alternate between two choices''.
%End of user code

\subsection{Trace Model}
\label{sec:Trace_Model}
%Start of user code Trace Model_interface
The Trace Model is used to represent execution traces as sequences of domain specific event occurrences, eventually annotated with values when the behavior of the model produces data.
%End of user code


\chapter{Component integration process}
%Start of user code Component integration process
In  order to create the GEMOC Studio, the components and metamodels must follow our development process.

\section{Providing and updating a contribution}
\subsection{Minimum requirement for a component}
A component should be integrated to the GEMOC Studio if the component :
\begin{itemize}
	\item is referenced in the GEMOC architecture model
	\item is a set of eclipse plugins/OSGI bundles
	\item has one feature referencing all plugins/bundles
	\item compiles using a maven script
	\item is deployed as a P2 repository (on Jenkins server or external URL)
	\item exposed a minimal documentation as Eclipse help (Quick start)
	\item offers a package sample (accessible through File>New>Sample in eclipse)
\end{itemize}
\subsection{Minimum requirement for a metamodel}
\begin{itemize}
	\item is referenced in the GEMOC architecture model
	\item is distributed as a part of an editor component (should follow the component minimal requirements)
\end{itemize}
\section{Continuous integration}
The resulting GEMOC Studio is available via the continuous integration server at the link below :
\newline
\url {http://ci.inria.fr/gemoc/job/org.gemoc.gemoc_studio.root/}
%End of user code

%Start of user code additionnal chapters or annexes

\newpage
\chapter{Appendix A : Tutorial "How to deliver a GEMOC Component distribution"}
This annex presents some guidelines to help the partners building the GEMOC Studio components.
\section{Sources}
\subsection{SCM}
The sources of the metamodels, components and samples developed for the project should be stored in the git repository available from the forge at link below :\newline
\url{https://gforge.inria.fr/projects/gemoc-dev/}
\newline\newline
Typical source retrieval should be done via :\newline
\textit{git clone git+ssh://yourforgelogin@scm.gforge.inria.fr/gitroot/gemoc-dev/gemoc-dev.git}
\subsection{Naming conventions}
In general the naming convention for a component contributions plug-in projects is the following :
\newline
\textit{\textless partner qualified name \textgreater.\textless component contribution name\textgreater .\textless contribution part\textgreater }
\newline\newline
For instance, the naming of the core of the component contribution Viewpoint DSL is the following:\textit{fr.obeo.dsl.viewpoint}
\newline
Notice that "fr.obeo" is the partner qualified name, "dsl.viewpoint" is the component contribution name, and core is the contribution part.
\newline

Distinguer connaissances propres (fr.partner.) et connaissances nouvelles (org.gemoc)
\subsection{Proiect organization}
\section{Update site}
Every component should be built and distributed as a P2 repository. The recommended compilation method is to use .
\newline
External tools and dependencies should be mirrored as P2 repositories in order to ensure their versions even if their original author update it without notice.
\newline
\textless TODO\textgreater
\section{GEMOC Studio}
GEMOC Studio should be used to design its plug-ins which will design all along the project.

It currently contains following tools :
\begin{itemize}
	\item Mylyn
	\item M2e (maven integration for eclipse)
	\item ComponentDSL
	\item SVN/Git
	\item XML editor
	\item some EMF tools
	\item Obeo designer
	\item Kermeta2
	\item Papyrus
	\item xText
\end{itemize}
It is downloading at link below :
\newline
\url {https://ci.inria.fr/gemoc/job/org.gemoc.gemoc_studio.root/}
\section{Required configuration}
To launch GEMOC Studio, these components should setup on your computer :
\begin{itemize}
	\item JDK JAVA 1.6 minimum version, JDK should download to link below :
	\newline
	\url {http://www.oracle.com/technetwork/java/javase/downloads/index.html}
	\item Scala IDE 2.9 for juno eclipse edition, it should download to link below :
	\newline
	\url {http://download.scala-ide.org/sdk/e38/scala29/stable/site}
\end{itemize}
\section{Life-cycle of new logical component}
\subsection{Presentation of an average component life-cycle}
A new component should have some validation steps :
\begin{itemize}
	\item Compilation of the project
	\item Build with Maven
	\item The new component shaould have a quickstart documentation
	\item The new component should contain an example presenting its functionalities
\end{itemize}
\subsection{Minimum requirement for a component}
A component should be integrated to the GEMOC studio if the component : 
\newline
\begin{itemize}
	\item is referenced in the GEMOC architecture model
	\item is a set of eclipse plugins/OSGI bundles
	\item has one feature referencing all plugins/bundles
	\item compiles using a maven script
	\item is deployed as a P2 repository (on Jenkins server or external URL)
	\item exposes a minimal documentation as Eclipse help (Quick start)
	\item offers a package sample (accessible through File>New>Sample in eclipse)
\end{itemize}

%End of user code
\end{document}
