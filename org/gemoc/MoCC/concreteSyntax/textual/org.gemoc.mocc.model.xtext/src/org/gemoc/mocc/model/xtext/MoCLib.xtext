// automatically generated by Xtext
grammar org.gemoc.mocc.model.xtext.MoCLib with fr.inria.aoste.timesquare.ccslkernel.library.xtext.CCSLLibrary


import "http://org.gemoc.mocc.model/0.1" as moccmetamodel
//import "http://org.gemoc.moc.model/0.1" as moccmetamodel
import "http://fr.inria.aoste.timemodel.ccslmodel" 
import "http://fr.inria.aoste.timemodel.primitivetypes" as PrimitivesTypeValue
import "http://fr.inria.aoste.timemodel.basicTypes" as BasicType
import "http://fr.inria.aoste.timemodel.ccslmodel.clockexpressionandrelation" as ClockExpressionAndRelation
import "http://fr.inria.aoste.timemodel.classicalexpression" as ClassicalExpression
import "http://fr.inria.aoste.timemodel" as TimeModel
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://fr.inria.aoste.timemodel.ccslmodel.clockexpressionandrelation.kernelexpression" as KernelExpression
  

StateBaseRelationLibrary returns moccmetamodel::StateBaseRelationLibrary:
	{moccmetamodel::StateBaseRelationLibrary}
	'Library' name=ID
	'{'
		(('imports' '{' ( imports+=ImportStatement)* '}' )? 
		(expressionLibraries+=ExpressionLibrary |
		 relationLibraries+=RelationLibrary  |
		 predefinedTypes+=Type  )*)
		
    '}';

RelationDefinition returns ClockExpressionAndRelation::RelationDefinition:
	UserRelationDefinition_Impl | ConditionalRelationDefinition | ExternalRelationDefinition |StateMachineRelationDefinition;

StateMachineRelationDefinition returns moccmetamodel::StateMachineRelationDefinition:
	{moccmetamodel::StateMachineRelationDefinition}
	'StateBasedRelationDefinition'name=ID '['declaration=[ClockExpressionAndRelation::RelationDeclaration|EString]']'
	'{'
		(concreteEntities+=ConcreteEntity)*
		(classicalExpressions+=BooleanExpression)*
		('init' initialState= [moccmetamodel::State|EString])';'
		((ownedStates+=State)|
		(ownedTransitions+=Transition))+
		
    '}';
 
State returns moccmetamodel::State:
	{moccmetamodel::State}
	'State' name=EString '('
		(('in' ':' inputTransitions+=[moccmetamodel::Transition|EString])? (','inputTransitions+=[moccmetamodel::Transition|EString])*';')?
		(('out' ':' outputTransitions+=[moccmetamodel::Transition|EString])? (','outputTransitions+=[moccmetamodel::Transition|EString])*';')?
	')'
;

Transition returns moccmetamodel::Transition: 
	'from' source=[moccmetamodel::State|EString] 'to' target=[moccmetamodel::State|EString]':'name=EString'('
		('if' guard=[ClassicalExpression::BooleanExpression|EString])?
		'when' trigger=Trigger
		('do' (actions+=Action))*
	')';

Action returns moccmetamodel::Action:
	IntegerAssignemnt | FinishClock
;

FinishClock returns moccmetamodel::FinishClock:
	'kill' '(' clock=[TimeModel::Clock|EString]')'
;

Trigger returns moccmetamodel::Trigger:
	((trueTriggers+=[TimeModel::Clock|EString])|
	('not' '(' falseTriggers+=[TimeModel::Clock|EString])')')+
	('.' (trueTriggers+=[TimeModel::Clock|EString])|
	('not' '(' falseTriggers+=[TimeModel::Clock|EString])')')*
	//('and' trigger+=[TimeModel::Clock|EString])*
;

IntegerExpression returns ClassicalExpression::IntegerExpression:
IntegerRef | UnaryIntPlus | UnaryIntMinus | IntPlus | IntMinus | IntMultiply | IntDivide | SeqGetHead | IntegerVariableRef | IntegerAssignemnt;


IntegerAssignemnt returns moccmetamodel::IntegerAssignment:
	'Assign' name=EString '('leftValue=IntegerRef ':=' rightValue=IntegerExpression ')'
;

IntEqual returns ClassicalExpression::IntEqual:
	'IntEqual' ('name' name=ID)?'('leftValue=IntegerExpression
		'==' rightValue=IntegerExpression
    ')';
